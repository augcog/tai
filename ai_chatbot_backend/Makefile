.PHONY: help install dev test lint format clean
.PHONY: add add-dev remove update show export
.PHONY: server db-init db-status admin test-api
.PHONY: docker-build docker-run

# Poetry with local virtual environment
POETRY = poetry
PYTHON = python
PIP = $(POETRY) run pip
PYTEST = $(POETRY) run pytest

# Default target
help: ## Show this help message
	@echo "TAI Backend Service - Poetry + Local .venv"
	@echo "=========================================="
	@echo ""
	@echo "ğŸš€ Quick Start:"
	@echo "  make install     # Install dependencies (macOS compatible)"
	@echo "  make dev         # Start development server"
	@echo ""
	@echo "ğŸ“¦ Setup Commands:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST) | grep -E "(install|setup)"
	@echo ""
	@echo "ğŸ› ï¸  Development Commands:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST) | grep -E "(dev|server|test|lint|format)"
	@echo ""
	@echo "ğŸ—„ï¸  Database Commands:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST) | grep -E "(db-|admin)"
	@echo ""
	@echo "ğŸ“¦ Package Management:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST) | grep -E "(add|remove|update|show)"
	@echo ""
	@echo "ğŸ’¡ Examples:"
	@echo "  make add PKG=torch              # Add production dependency"
	@echo "  make add-dev PKG=pytest         # Add development dependency"
	@echo "  make remove PKG=outdated-pkg    # Remove dependency"
	@echo ""
	@echo "ğŸ–¥ï¸  Platform-Specific:"
	@echo "  make install     # macOS/Windows development (no GPU)"
	@echo "  make install-gpu # Linux production (with vLLM/CUDA)"
	@echo ""

# Installation and setup
install: ## Install all dependencies with Poetry in local .venv (macOS compatible)
	@echo "ğŸ“¦ Installing dependencies with Poetry (without GPU dependencies)..."
	@echo "ğŸ”§ Configuring Poetry to use local virtual environment..."
	$(POETRY) config virtualenvs.in-project true
	$(POETRY) config virtualenvs.create true
	@echo "ğŸ“¦ Installing dependencies..."
	$(POETRY) install
	@echo "âœ… Dependencies installed in $(shell pwd)/.venv"
	@echo "ğŸ“ Virtual environment: $(shell $(POETRY) env info --path)"
	@echo "ğŸ’¡ For GPU support on production servers, use: make install-gpu"

install-dev: ## Install with development dependencies (without GPU)
	@echo "ğŸ“¦ Installing with development dependencies (without GPU dependencies)..."
	$(POETRY) config virtualenvs.in-project true
	$(POETRY) config virtualenvs.create true
	$(POETRY) install --with dev
	@echo "âœ… Development environment ready!"

install-gpu: ## Install with GPU dependencies for production servers
	@echo "ğŸ“¦ Installing with GPU dependencies (Linux/CUDA required)..."
	@echo "ğŸ”§ Configuring Poetry to use local virtual environment..."
	$(POETRY) config virtualenvs.in-project true
	$(POETRY) config virtualenvs.create true
	@echo "ğŸ“¦ Installing all dependencies including GPU support..."
	$(POETRY) install --with gpu
	@echo "âœ… GPU dependencies installed in $(shell pwd)/.venv"
	@echo "ğŸ“ Virtual environment: $(shell $(POETRY) env info --path)"
	@echo "âš ï¸  Note: GPU dependencies require Linux with NVIDIA CUDA support"

install-full: ## Install all dependencies including GPU (production deployment)
	@echo "ğŸ“¦ Installing all dependencies for production deployment..."
	@echo "ğŸ”§ Configuring Poetry to use local virtual environment..."
	$(POETRY) config virtualenvs.in-project true
	$(POETRY) config virtualenvs.create true
	@echo "ğŸ“¦ Installing all dependencies..."
	$(POETRY) install --with dev --with gpu
	@echo "âœ… Full environment ready with GPU support!"

# Development server
dev: server ## Start development server (alias for server)

server: ## Start the FastAPI development server
	@echo "ğŸš€ Starting TAI Backend Server..."
	@echo "ğŸ“ Server will be available at: http://localhost:8000"
	@echo "ğŸ“š API Documentation: http://localhost:8000/docs"
	@echo "ğŸ”§ Admin Interface: http://localhost:8000/admin"
	@echo "ğŸŒ Using remote model mode for development"
	@echo ""
	LLM_MODE=remote $(PYTHON) main.py

# Database operations
db-init: ## Initialize database and import files
	@echo "ğŸ—„ï¸  Initializing database..."
	$(PYTHON) scripts/initialize_db_and_files.py
	@echo "âœ… Database initialized!"

db-status: ## Check database status
	@echo "ğŸ—„ï¸  Checking database status..."
	@curl -s http://localhost:8000/database-status 2>/dev/null || echo "âŒ Server not running. Start with 'make dev'"

admin: ## Open admin interface (server must be running)
	@echo "ğŸ”§ Opening admin interface..."
	@echo "Visit: http://localhost:8000/admin"
	@command -v open >/dev/null 2>&1 && open http://localhost:8000/admin || echo "Manual: http://localhost:8000/admin"

# Testing
test: ## Run all tests
	@echo "ğŸ§ª Running backend tests..."
	$(PYTEST) -v tests/

test-unit: ## Run unit tests only
	@echo "ğŸ§ª Running unit tests..."
	$(PYTEST) -v -m "unit" tests/

test-integration: ## Run integration tests only
	@echo "ğŸ§ª Running integration tests..."
	$(PYTEST) -v -m "integration" tests/

test-api: ## Run API tests only
	@echo "ğŸ§ª Running API tests..."
	$(PYTEST) -v -m "api" tests/

test-cov: ## Run tests with coverage report
	@echo "ğŸ§ª Running tests with coverage..."
	$(PYTEST) --cov=app --cov-report=html --cov-report=term-missing tests/

test-watch: ## Run tests in watch mode
	@echo "ğŸ§ª Running tests in watch mode..."
	$(PYTEST) -f tests/

# Code quality
lint: ## Run linting checks
	@echo "ğŸ” Running linting checks..."
	$(POETRY) run ruff check .
	@echo "âœ… Linting checks completed!"

format: ## Format code and auto-fix linting issues
	@echo "ğŸ¨ Formatting code and auto-fixing linting issues..."
	$(POETRY) run ruff format .
	$(POETRY) run ruff check --fix .
	@echo "âœ… Code formatted and linting issues auto-fixed!"


# Package management with Poetry
add: ## Add production dependency (use: make add PKG=package-name)
	@if [ -z "$(PKG)" ]; then echo "âŒ Usage: make add PKG=package-name"; exit 1; fi
	@echo "ğŸ“¦ Adding package $(PKG) with Poetry..."
	$(POETRY) add $(PKG)
	@echo "âœ… Package $(PKG) added and pyproject.toml updated!"

add-dev: ## Add development dependency (use: make add-dev PKG=package-name)
	@if [ -z "$(PKG)" ]; then echo "âŒ Usage: make add-dev PKG=package-name"; exit 1; fi
	@echo "ğŸ“¦ Adding development package $(PKG) with Poetry..."
	$(POETRY) add --group dev $(PKG)
	@echo "âœ… Development package $(PKG) added!"

remove: ## Remove dependency (use: make remove PKG=package-name)
	@if [ -z "$(PKG)" ]; then echo "âŒ Usage: make remove PKG=package-name"; exit 1; fi
	@echo "ğŸ“¦ Removing package $(PKG) with Poetry..."
	$(POETRY) remove $(PKG)
	@echo "âœ… Package $(PKG) removed and pyproject.toml updated!"

update: ## Update all dependencies
	@echo "â¬†ï¸  Updating dependencies with Poetry..."
	$(POETRY) update
	@echo "âœ… Dependencies updated and poetry.lock refreshed!"

update-pkg: ## Update specific package (use: make update-pkg PKG=package-name)
	@if [ -z "$(PKG)" ]; then echo "âŒ Usage: make update-pkg PKG=package-name"; exit 1; fi
	@echo "â¬†ï¸  Updating package $(PKG) with Poetry..."
	$(POETRY) update $(PKG)
	@echo "âœ… Package $(PKG) updated!"

show: ## Show package info (use: make show PKG=package-name)
	@if [ -z "$(PKG)" ]; then \
		echo "ğŸ“Š Showing all dependencies:"; \
		$(POETRY) show; \
	else \
		echo "ğŸ“Š Showing package info: $(PKG)"; \
		$(POETRY) show $(PKG); \
	fi

show-tree: ## Show dependency tree
	@echo "ğŸ“Š Dependency tree:"
	$(POETRY) show --tree

export: ## Export requirements.txt for deployment
	@echo "ğŸ“¦ Exporting requirements.txt with Poetry..."
	$(POETRY) export --format=requirements.txt --output=requirements.txt --without-hashes
	@echo "âœ… requirements.txt generated from pyproject.toml!"

lock: ## Update poetry.lock file
	@echo "ğŸ”’ Updating poetry.lock..."
	$(POETRY) lock
	@echo "âœ… Lock file updated!"

# Maintenance
clean: ## Clean build artifacts and cache
	@echo "ğŸ§¹ Cleaning build artifacts..."
	@find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
	@find . -type d -name ".pytest_cache" -exec rm -rf {} + 2>/dev/null || true
	@find . -type d -name ".mypy_cache" -exec rm -rf {} + 2>/dev/null || true
	@find . -type d -name "*.egg-info" -exec rm -rf {} + 2>/dev/null || true
	@find . -type f -name "*.pyc" -delete 2>/dev/null || true
	@rm -rf dist/ build/ .coverage htmlcov/ .tox/ .ruff_cache/
	@echo "âœ… Cleanup completed!"

clean-logs: ## Clean log files
	@echo "ğŸ§¹ Cleaning log files..."
	@rm -f logs.log *.log
	@echo "âœ… Log files cleaned!"

clean-venv: ## Remove virtual environment
	@echo "ğŸ—‘ï¸  Removing virtual environment..."
	$(POETRY) env remove --all
	@echo "âœ… Virtual environment removed!"

# Docker operations
docker-build: ## Build Docker image
	@echo "ğŸ³ Building Docker image..."
	docker build -t tai-backend .

docker-run: ## Run Docker container
	@echo "ğŸ³ Running Docker container..."
	docker run -p 8000:8000 --env-file .env tai-backend

# Virtual environment management
venv-info: ## Show virtual environment information
	@echo "ğŸ Virtual Environment Information"
	@echo "================================="
	$(POETRY) env info

venv-activate: ## Show command to activate virtual environment manually
	@echo "ğŸ To manually activate the virtual environment, run:"
	@echo "$(POETRY) shell"

venv-path: ## Show virtual environment path
	@echo "ğŸ“ Virtual environment path:"
	@$(POETRY) env info --path

venv-recreate: ## Recreate virtual environment
	@echo "ğŸ”„ Recreating virtual environment..."
	$(POETRY) env remove --all || true
	$(POETRY) config virtualenvs.in-project true
	$(POETRY) install
	@echo "âœ… Virtual environment recreated!"

# Health checks and info
health: ## Check service health
	@echo "ğŸ¥ Checking service health..."
	@curl -s http://localhost:8000/health 2>/dev/null || echo "âŒ Service not running. Start with 'make dev'"

info: ## Show environment information
	@echo "â„¹ï¸  Environment Information"
	@echo "=========================="
	@echo "Python: $(shell python --version 2>/dev/null || echo 'Not found')"
	@echo "Poetry: $(shell $(POETRY) --version 2>/dev/null || echo 'Not found')"
	@echo "FastAPI: $(shell $(PYTHON) -c 'import fastapi; print(fastapi.__version__)' 2>/dev/null || echo 'Not installed')"
	@echo "Working Directory: $(shell pwd)"
	@echo ""
	@echo "ğŸ”§ Virtual Environment:"
	@$(POETRY) env info --path 2>/dev/null || echo "âŒ No virtual environment found"
	@echo ""
	@echo "ğŸ”§ Configuration:"
	@echo "Host: $(shell grep -E '^HOST=' .env 2>/dev/null | cut -d= -f2 || echo 'localhost')"
	@echo "Port: $(shell grep -E '^PORT=' .env 2>/dev/null | cut -d= -f2 || echo '8000')"
	@echo "Environment: $(shell grep -E '^ENVIRONMENT=' .env 2>/dev/null | cut -d= -f2 || echo 'development')"

# Development workflow shortcuts
setup: install db-init ## Complete setup for new developers
	@echo ""
	@echo "ğŸ‰ TAI Backend setup complete!"
	@echo ""
	@echo "ğŸš€ Next steps:"
	@echo "  make dev         # Start the development server"
	@echo "  make test        # Run the test suite"
	@echo "  make admin       # Open admin interface"

check: ## Run all quality checks (lint + tests)
	@echo "ğŸ” Running all quality checks..."
	$(POETRY) run ruff check .
	$(PYTEST) -v tests/
	@echo "âœ… All quality checks passed!"

ci: install check ## Run CI pipeline locally
	@echo "âœ… CI pipeline completed successfully!"
