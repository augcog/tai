Parsed Headers, Levels and Contents:
h1: Python API reference
Contents:
This reference contains all the details the Python API. To consult a previous reference for a specific CARLA release, change the documentation version using the panel in the bottom right corner.<br>This will change the whole documentation to a previous state. Remember that the <i>latest</i> version is the `dev` branch and may show features not available in any packaged versions of CARLA.<hr>  
=====================================

h2: carla.Actor<a name="carla.Actor"></a>
Contents:
CARLA defines actors as anything that plays a role in the simulation or can be moved around. That includes: pedestrians, vehicles, sensors and traffic signs (considering traffic lights as part of these). Actors are spawned in the simulation by [carla.World](#carla.World) and they need for a [carla.ActorBlueprint](#carla.ActorBlueprint) to be created. These blueprints belong into a library provided by CARLA, find more about them [here](bp_library.md).  
=====================================

h3: Instance Variables
Contents:
- <a name="command.SpawnActor.transform"></a>**<font color="#f8805a">transform</font>** (_[carla.Transform](#carla.Transform)_)  Transform to be applied.  - <a name="command.SpawnActor.parent_id"></a>**<font color="#f8805a">parent_id</font>** (_int_)  Identificator of the parent actor.  
=====================================

h3: Methods
Contents:
- <a name="command.SpawnActor.__init__"></a>**<font color="#7fb800">\__init__</font>**(<font color="#00a6ed">**self**</font>)  - <a name="command.SpawnActor.__init__"></a>**<font color="#7fb800">\__init__</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**blueprint**</font>, <font color="#00a6ed">**transform**</font>)      - **Parameters:**        - `blueprint` (_[carla.ActorBlueprint](#carla.ActorBlueprint)_)          - `transform` (_[carla.Transform](#carla.Transform)_)  - <a name="command.SpawnActor.__init__"></a>**<font color="#7fb800">\__init__</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**blueprint**</font>, <font color="#00a6ed">**transform**</font>, <font color="#00a6ed">**parent**</font>)      - **Parameters:**        - `blueprint` (_[carla.ActorBlueprint](#carla.ActorBlueprint)_)          - `transform` (_[carla.Transform](#carla.Transform)_)          - `parent` (_[carla.Actor](#carla.Actor) or int_)  - <a name="command.SpawnActor.then"></a>**<font color="#7fb800">then</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**command**</font>)  Links another command to be executed right after. It allows to ease very common flows such as spawning a set of vehicles by command and then using this method to set them to autopilot automatically.      - **Parameters:**        - `command` (_any carla Command_) - a Carla command.  ---[comment]: <> (=========================)[comment]: <> (PYTHON API SCRIPT SNIPETS)[comment]: <> (=========================)<div id="snipets-container" class="Container" onmouseover='this.style["overflowX"]="scroll";' onmouseout='this.style["overflowX"]="visible";'></div><script>function CopyToClipboard(containerid) {if (document.selection) {var range = document.body.createTextRange();range.moveToElementText(document.getElementById(containerid));range.select().createTextRange();document.execCommand("copy");} else if (window.getSelection) {var range = document.createRange();range.selectNode(document.getElementById(containerid));window.getSelection().addRange(range);document.execCommand("copy");}}</script><script>function CloseSnipet() {document.getElementById("snipets-container").innerHTML = null;}</script>  <div id ="carla.ActorBlueprint.set_attribute-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.ActorBlueprint.set_attribute</p><div id="carla.ActorBlueprint.set_attribute-code" class="SnipetContent">```py  # This recipe changes attributes of different type of blueprint actors.# ...walker_bp = world.get_blueprint_library().filter('walker.pedestrian.0002')walker_bp.set_attribute('is_invincible', True)# ...# Changes attribute randomly by the recommended valuevehicle_bp = wolrd.get_blueprint_library().filter('vehicle.bmw.*')color = random.choice(vehicle_bp.get_attribute('color').recommended_values)vehicle_bp.set_attribute('color', color)# ...camera_bp = world.get_blueprint_library().filter('sensor.camera.rgb')camera_bp.set_attribute('image_size_x', 600)camera_bp.set_attribute('image_size_y', 600)# ...  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.ActorBlueprint.set_attribute-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  </div>  <div id ="carla.Client.apply_batch_sync-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.Client.apply_batch_sync</p><div id="carla.Client.apply_batch_sync-code" class="SnipetContent">```py  # 0. Choose a blueprint fo the walkersworld = client.get_world()blueprintsWalkers = world.get_blueprint_library().filter("walker.pedestrian.*")walker_bp = random.choice(blueprintsWalkers)# 1. Take all the random locations to spawnspawn_points = []for i in range(50):    spawn_point = carla.Transform()    spawn_point.location = world.get_random_location_from_navigation()    if (spawn_point.location != None):        spawn_points.append(spawn_point)# 2. Build the batch of commands to spawn the pedestriansbatch = []for spawn_point in spawn_points:    walker_bp = random.choice(blueprintsWalkers)    batch.append(carla.command.SpawnActor(walker_bp, spawn_point))# 2.1 apply the batchresults = client.apply_batch_sync(batch, True)for i in range(len(results)):    if results[i].error:        logging.error(results[i].error)    else:        walkers_list.append({"id": results[i].actor_id})# 3. Spawn walker AI controllers for each walkerbatch = []walker_controller_bp = world.get_blueprint_library().find('controller.ai.walker')for i in range(len(walkers_list)):    batch.append(carla.command.SpawnActor(walker_controller_bp, carla.Transform(), walkers_list[i]["id"]))# 3.1 apply the batchresults = client.apply_batch_sync(batch, True)for i in range(len(results)):    if results[i].error:        logging.error(results[i].error)    else:        walkers_list[i]["con"] = results[i].actor_id# 4. Put altogether the walker and controller idsfor i in range(len(walkers_list)):    all_id.append(walkers_list[i]["con"])    all_id.append(walkers_list[i]["id"])all_actors = world.get_actors(all_id)# wait for a tick to ensure client receives the last transform of the walkers we have just createdworld.wait_for_tick()# 5. initialize each controller and set target to walk to (list is [controller, actor, controller, actor ...])for i in range(0, len(all_actors), 2):    # start walker    all_actors[i].start()    # set walk to random point    all_actors[i].go_to_location(world.get_random_location_from_navigation())    # random max speed    all_actors[i].set_max_speed(1 + random.random())    # max speed between 1 and 2 (default is 1.4 m/s)  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.Client.apply_batch_sync-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  </div>  <div id ="carla.Client.__init__-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.Client.__init__</p><div id="carla.Client.__init__-code" class="SnipetContent">```py  # This recipe shows in every script provided in PythonAPI/Examples # and it is used to parse the client creation arguments when running the script.     argparser = argparse.ArgumentParser(        description=__doc__)    argparser.add_argument(        '--host',        metavar='H',        default='127.0.0.1',        help='IP of the host server (default: 127.0.0.1)')    argparser.add_argument(        '-p', '--port',        metavar='P',        default=2000,        type=int,        help='TCP port to listen to (default: 2000)')    argparser.add_argument(        '-s', '--speed',        metavar='FACTOR',        default=1.0,        type=float,        help='rate at which the weather changes (default: 1.0)')    args = argparser.parse_args()    speed_factor = args.speed    update_freq = 0.1 / speed_factor    client = carla.Client(args.host, args.port)  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.Client.__init__-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  </div>  <div id ="carla.DebugHelper.draw_box-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.DebugHelper.draw_box</p><div id="carla.DebugHelper.draw_box-code" class="SnipetContent">```py  # This recipe shows how to draw traffic light actor bounding boxes from a world snapshot.# ....debug = world.debugworld_snapshot = world.get_snapshot()for actor_snapshot in world_snapshot:    actual_actor = world.get_actor(actor_snapshot.id)    if actual_actor.type_id == 'traffic.traffic_light':        debug.draw_box(carla.BoundingBox(actor_snapshot.get_transform().location,carla.Vector3D(0.5,0.5,2)),actor_snapshot.get_transform().rotation, 0.05, carla.Color(255,0,0,0),0)# ...  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.DebugHelper.draw_box-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  <img src="/img/snipets_images/carla.DebugHelper.draw_box.jpg">  </div>  <div id ="carla.DebugHelper.draw_string-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.DebugHelper.draw_string</p><div id="carla.DebugHelper.draw_string-code" class="SnipetContent">```py  # This recipe is a modification of lane_explorer.py example.# It draws the path of an actor through the world, printing information at each waypoint.# ...current_w = map.get_waypoint(vehicle.get_location())while True:    next_w = map.get_waypoint(vehicle.get_location(), lane_type=carla.LaneType.Driving | carla.LaneType.Shoulder | carla.LaneType.Sidewalk )    # Check if the vehicle is moving    if next_w.id != current_w.id:        vector = vehicle.get_velocity()        # Check if the vehicle is on a sidewalk        if current_w.lane_type == carla.LaneType.Sidewalk:            draw_waypoint_union(debug, current_w, next_w, cyan if current_w.is_junction else red, 60)        else:            draw_waypoint_union(debug, current_w, next_w, cyan if current_w.is_junction else green, 60)        debug.draw_string(current_w.transform.location, str('%15.0f km/h' % (3.6 * math.sqrt(vector.x**2 + vector.y**2 + vector.z**2))), False, orange, 60)        draw_transform(debug, current_w.transform, white, 60)    # Update the current waypoint and sleep for some time    current_w = next_w    time.sleep(args.tick_time)# ...  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.DebugHelper.draw_string-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  </div>  <div id ="carla.Map.get_waypoint-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.Map.get_waypoint</p><div id="carla.Map.get_waypoint-code" class="SnipetContent">```py  # This recipe shows the current traffic rules affecting the vehicle. # Shows the current lane type and if a lane change can be done in the actual lane or the surrounding ones.# ...waypoint = world.get_map().get_waypoint(vehicle.get_location(),project_to_road=True, lane_type=(carla.LaneType.Driving | carla.LaneType.Shoulder | carla.LaneType.Sidewalk))print("Current lane type: " + str(waypoint.lane_type))# Check current lane change allowedprint("Current Lane change:  " + str(waypoint.lane_change))# Left and Right lane markingsprint("L lane marking type: " + str(waypoint.left_lane_marking.type))print("L lane marking change: " + str(waypoint.left_lane_marking.lane_change))print("R lane marking type: " + str(waypoint.right_lane_marking.type))print("R lane marking change: " + str(waypoint.right_lane_marking.lane_change))# ...  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.Map.get_waypoint-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  <img src="/img/snipets_images/carla.Map.get_waypoint.jpg">  </div>  <div id ="carla.Sensor.listen-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.Sensor.listen</p><div id="carla.Sensor.listen-code" class="SnipetContent">```py  # This recipe applies a color conversion to the image taken by a camera sensor,# so it is converted to a semantic segmentation image.# ...camera_bp = world.get_blueprint_library().filter('sensor.camera.semantic_segmentation')# ...cc = carla.ColorConverter.CityScapesPalettecamera.listen(lambda image: image.save_to_disk('output/%06d.png' % image.frame, cc))# ...  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.Sensor.listen-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  </div>  <div id ="carla.TrafficLight.set_state-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.TrafficLight.set_state</p><div id="carla.TrafficLight.set_state-code" class="SnipetContent">```py  # This recipe changes from red to green the traffic light that affects the vehicle. # This is done by detecting if the vehicle actor is at a traffic light.# ...world = client.get_world()spectator = world.get_spectator()vehicle_bp = random.choice(world.get_blueprint_library().filter('vehicle.bmw.*'))transform = random.choice(world.get_map().get_spawn_points())vehicle = world.try_spawn_actor(vehicle_bp, transform)# Wait for world to get the vehicle actorworld.tick()world_snapshot = world.wait_for_tick()actor_snapshot = world_snapshot.find(vehicle.id)# Set spectator at given transform (vehicle transform)spectator.set_transform(actor_snapshot.get_transform())# ...# ...if vehicle_actor.is_at_traffic_light():    traffic_light = vehicle_actor.get_traffic_light()    if traffic_light.get_state() == carla.TrafficLightState.Red:       # world.hud.notification("Traffic light changed! Good to go!")        traffic_light.set_state(carla.TrafficLightState.Green)# ...  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.TrafficLight.set_state-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  <img src="/img/snipets_images/carla.TrafficLight.set_state.gif">  </div>  <div id ="carla.Vehicle.set_wheel_steer_direction-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.Vehicle.set_wheel_steer_direction</p><div id="carla.Vehicle.set_wheel_steer_direction-code" class="SnipetContent">```py  # Sets the appearance of the vehicles front wheels to 40Â°. Vehicle physics will not be affected.vehicle.set_wheel_steer_direction(carla.VehicleWheelLocation.FR_Wheel, 40.0)vehicle.set_wheel_steer_direction(carla.VehicleWheelLocation.FL_Wheel, 40.0)  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.Vehicle.set_wheel_steer_direction-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  </div>  <div id ="carla.WalkerAIController.stop-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.WalkerAIController.stop</p><div id="carla.WalkerAIController.stop-code" class="SnipetContent">```py  #To destroy the pedestrians, stop them from the navigation, and then destroy the objects (actor and controller).# stop pedestrians (list is [controller, actor, controller, actor ...])for i in range(0, len(all_id), 2):    all_actors[i].stop()# destroy pedestrian (actor and controller)client.apply_batch([carla.command.DestroyActor(x) for x in all_id])  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.WalkerAIController.stop-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  </div>  <div id ="carla.World.enable_environment_objects-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.World.enable_environment_objects</p><div id="carla.World.enable_environment_objects-code" class="SnipetContent">```py  # This recipe turn visibility off and on for two specifc buildings on the map# Get the buildings in the worldworld = client.get_world()env_objs = world.get_environment_objects(carla.CityObjectLabel.Buildings)# Access individual building IDs and save in a setbuilding_01 = env_objs[0]building_02 = env_objs[1]objects_to_toggle = {building_01.id, building_02.id}# Toggle buildings offworld.enable_environment_objects(objects_to_toggle, False)# Toggle buildings onworld.enable_environment_objects(objects_to_toggle, True)  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.World.enable_environment_objects-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  </div>  <div id ="carla.World.get_spectator-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.World.get_spectator</p><div id="carla.World.get_spectator-code" class="SnipetContent">```py  # This recipe spawns an actor and the spectator camera at the actor's location.# ...world = client.get_world()spectator = world.get_spectator()vehicle_bp = random.choice(world.get_blueprint_library().filter('vehicle.bmw.*'))transform = random.choice(world.get_map().get_spawn_points())vehicle = world.try_spawn_actor(vehicle_bp, transform)# Wait for world to get the vehicle actorworld.tick()world_snapshot = world.wait_for_tick()actor_snapshot = world_snapshot.find(vehicle.id)# Set spectator at given transform (vehicle transform)spectator.set_transform(actor_snapshot.get_transform())# ...  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.World.get_spectator-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  </div>  <div id ="carla.World.load_map_layer-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.World.load_map_layer</p><div id="carla.World.load_map_layer-code" class="SnipetContent">```py  # This recipe toggles on several layers in our "_Opt" maps# Load town one with only minimum layout (roads, sidewalks, traffic lights and traffic signs)world = client.load_world('Town01_Opt', carla.MapLayer.None)# Toggle all buildings onworld.load_map_layer(carla.MapLayer.Buildings)# Toggle all foliage onworld.load_map_layer(carla.MapLayer.Foliage)# Toggle all parked vehicles onworld.load_map_layer(carla.MapLayer.ParkedVehicles)  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.World.load_map_layer-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  </div>  <div id ="carla.World.spawn_actor-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.World.spawn_actor</p><div id="carla.World.spawn_actor-code" class="SnipetContent">```py  # This recipe attaches different camera / sensors to a vehicle with different attachments.# ...camera = world.spawn_actor(rgb_camera_bp, transform, attach_to=vehicle, attachment_type=Attachment.Rigid)# Default attachment:  Attachment.Rigidgnss_sensor = world.spawn_actor(sensor_gnss_bp, transform, attach_to=vehicle)collision_sensor = world.spawn_actor(sensor_collision_bp, transform, attach_to=vehicle)lane_invasion_sensor = world.spawn_actor(sensor_lane_invasion_bp, transform, attach_to=vehicle)# ...  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.World.spawn_actor-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  </div>  <div id ="carla.World.unload_map_layer-snipet" style="display: none;"><p class="SnipetFont">Snippet for carla.World.unload_map_layer</p><div id="carla.World.unload_map_layer-code" class="SnipetContent">```py  # This recipe toggles off several layers in our "_Opt" maps# Load town one with minimum layout (roads, sidewalks, traffic lights and traffic signs)# as well as buildings and parked vehiclesworld = client.load_world('Town01_Opt', carla.MapLayer.Buildings | carla.MapLayer.ParkedVehicles) # Toggle all buildings offworld.unload_map_layer(carla.MapLayer.Buildings)# Toggle all parked vehicles offworld.unload_map_layer(carla.MapLayer.ParkedVehicles)  ```<button id="button1" class="CopyScript" onclick="CopyToClipboard('carla.World.unload_map_layer-code')">Copy snippet</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<button id="button1" class="CloseSnipet" onclick="CloseSnipet()">Close snippet</button><br><br>  </div>  </div><script>function ButtonAction(container_name){if(window_big){snipet_name = container_name.replace('-snipet_button','-snipet');document.getElementById("snipets-container").innerHTML = document.getElementById(snipet_name).innerHTML;}else{document.getElementById("snipets-container").innerHTML = null;code_name = container_name.replace('-snipet_button','-code');var range = document.createRange();range.selectNode(document.getElementById(code_name));alert(range);}}function WindowResize(){if(window.innerWidth > 1200){window_big = true;}else{window_big = false;}}var window_big;if(window.innerWidth > 1200){window_big = true;}else{window_big = false;}buttons = document.getElementsByClassName('SnipetButton')for (let i = 0; i < buttons.length; i++) {buttons[i].addEventListener("click",function(){ButtonAction(buttons[i].id);},true);}window.onresize = WindowResize;</script>
=====================================

h5: Getters
Contents:
- <a name="carla.World.get_actor"></a>**<font color="#7fb800">get_actor</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**actor_id**</font>)  Looks up for an actor by ID and returns <b>None</b> if not found.      - **Parameters:**        - `actor_id` (_int_)      - **Return:** _[carla.Actor](#carla.Actor)_  - <a name="carla.World.get_actors"></a>**<font color="#7fb800">get_actors</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**actor_ids**=None</font>)  Retrieves a list of [carla.Actor](#carla.Actor) elements, either using a list of IDs provided or just listing everyone on stage. If an ID does not correspond with any actor, it will be excluded from the list returned, meaning that both the list of IDs and the list of actors may have different lengths.      - **Parameters:**        - `actor_ids` (_list_) - The IDs of the actors being searched. By default it is set to <b>None</b> and returns every actor on scene.      - **Return:** _[carla.ActorList](#carla.ActorList)_  - <a name="carla.World.get_blueprint_library"></a>**<font color="#7fb800">get_blueprint_library</font>**(<font color="#00a6ed">**self**</font>)  Returns a list of actor blueprints available to ease the spawn of these into the world.      - **Return:** _[carla.BlueprintLibrary](#carla.BlueprintLibrary)_  - <a name="carla.World.get_environment_objects"></a>**<font color="#7fb800">get_environment_objects</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**object_type**=Any</font>)  Returns a list of EnvironmentObject with the requested semantic tag.  The method returns all the EnvironmentObjects in the level by default, but the query can be filtered by semantic tags with the argument `object_type`.      - **Parameters:**        - `object_type` (_[carla.CityObjectLabel](#carla.CityObjectLabel)_) - Semantic tag of the EnvironmentObjects that are returned.      - **Return:** _array([carla.EnvironmentObject](#carla.EnvironmentObject))_  - <a name="carla.World.get_level_bbs"></a>**<font color="#7fb800">get_level_bbs</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**actor_type**=Any</font>)  Returns an array of bounding boxes with location and rotation in world space. The method returns all the bounding boxes in the level by default, but the query can be filtered by semantic tags with the argument `actor_type`.      - **Parameters:**        - `actor_type` (_[carla.CityObjectLabel](#carla.CityObjectLabel)_) - Semantic tag of the elements contained in the bounding boxes that are returned.      - **Return:** _array([carla.BoundingBox](#carla.BoundingBox))_  - <a name="carla.World.get_lightmanager"></a>**<font color="#7fb800">get_lightmanager</font>**(<font color="#00a6ed">**self**</font>)  Returns an instance of [carla.LightManager](#carla.LightManager) that can be used to handle the lights in the scene.      - **Return:** _[carla.LightManager](#carla.LightManager)_  - <a name="carla.World.get_map"></a>**<font color="#7fb800">get_map</font>**(<font color="#00a6ed">**self**</font>)  Asks the server for the XODR containing the map file, and returns this parsed as a [carla.Map](#carla.Map).      - **Return:** _[carla.Map](#carla.Map)_      - **Warning:** <font color="#ED2F2F">_This method does call the simulation. It is expensive, and should only be called once.  _</font>  - <a name="carla.World.get_names_of_all_objects"></a>**<font color="#7fb800">get_names_of_all_objects</font>**(<font color="#00a6ed">**self**</font>)  Returns a list of the names of all objects in the scene that can be painted with the apply texture functions.      - **Return:** _list(str)_  - <a name="carla.World.get_random_location_from_navigation"></a>**<font color="#7fb800">get_random_location_from_navigation</font>**(<font color="#00a6ed">**self**</font>)  This can only be used with walkers. It retrieves a random location to be used as a destination using the __<font color="#7fb800">go_to_location()</font>__ method in [carla.WalkerAIController](#carla.WalkerAIController). This location will be part of a sidewalk. Roads, crosswalks and grass zones are excluded. The method does not take into consideration locations of existing actors so if a collision happens when trying to spawn an actor, it will return an error. Take a look at [`generate_traffic.py`](https://github.com/carla-simulator/carla/blob/master/PythonAPI/examples/generate_traffic.py) for an example.      - **Return:** _[carla.Location](#carla.Location)_  - <a name="carla.World.get_settings"></a>**<font color="#7fb800">get_settings</font>**(<font color="#00a6ed">**self**</font>)  Returns an object containing some data about the simulation such as synchrony between client and server or rendering mode.      - **Return:** _[carla.WorldSettings](#carla.WorldSettings)_  - <a name="carla.World.get_snapshot"></a>**<font color="#7fb800">get_snapshot</font>**(<font color="#00a6ed">**self**</font>)  Returns a snapshot of the world at a certain moment comprising all the information about the actors.      - **Return:** _[carla.WorldSnapshot](#carla.WorldSnapshot)_  - <a name="carla.World.get_spectator"></a>**<font color="#7fb800">get_spectator</font>**(<font color="#00a6ed">**self**</font>)<button class="SnipetButton" id="carla.World.get_spectator-snipet_button">snippet &rarr;</button>  Returns the spectator actor. The spectator is a special type of actor created by Unreal Engine, usually with ID=0, that acts as a camera and controls the view in the simulator window.      - **Return:** _[carla.Actor](#carla.Actor)_  - <a name="carla.World.get_traffic_light"></a>**<font color="#7fb800">get_traffic_light</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**landmark**</font>)  Provided a landmark, returns the traffic light object it describes.      - **Parameters:**        - `landmark` (_[carla.Landmark](#carla.Landmark)_) - The landmark object describing a traffic light.      - **Return:** _[carla.TrafficLight](#carla.TrafficLight)_  - <a name="carla.World.get_traffic_light_from_opendrive_id"></a>**<font color="#7fb800">get_traffic_light_from_opendrive_id</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**traffic_light_id**</font>)  Returns the traffic light actor corresponding to the indicated OpenDRIVE id.      - **Parameters:**        - `traffic_light_id` (_str_) - The OpenDRIVE id.      - **Return:** _[carla.TrafficLight](#carla.TrafficLight)_  - <a name="carla.World.get_traffic_lights_from_waypoint"></a>**<font color="#7fb800">get_traffic_lights_from_waypoint</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**waypoint**</font>, <font color="#00a6ed">**distance**</font>)  This function performs a search along the road in front of the specified waypoint and returns a list of traffic light actors found in the specified search distance.      - **Parameters:**        - `waypoint` (_[carla.Waypoint](#carla.Waypoint)_) - The input waypoint.          - `distance` (_float_) - Search distance.      - **Return:** _list([carla.TrafficLight](#carla.TrafficLight))_  - <a name="carla.World.get_traffic_lights_in_junction"></a>**<font color="#7fb800">get_traffic_lights_in_junction</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**junction_id**</font>)  Returns the list of traffic light actors affecting the junction indicated in `junction_id`.      - **Parameters:**        - `junction_id` (_int_) - The id of the junction.      - **Return:** _list([carla.TrafficLight](#carla.TrafficLight))_  - <a name="carla.World.get_traffic_sign"></a>**<font color="#7fb800">get_traffic_sign</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**landmark**</font>)  Provided a landmark, returns the traffic sign object it describes.      - **Parameters:**        - `landmark` (_[carla.Landmark](#carla.Landmark)_) - The landmark object describing a traffic sign.      - **Return:** _[carla.TrafficSign](#carla.TrafficSign)_  - <a name="carla.World.get_vehicles_light_states"></a>**<font color="#7fb800">get_vehicles_light_states</font>**(<font color="#00a6ed">**self**</font>)  Returns a dict where the keys are [carla.Actor](#carla.Actor) IDs and the values are [carla.VehicleLightState](#carla.VehicleLightState) of that vehicle.      - **Return:** _dict_  - <a name="carla.World.get_weather"></a>**<font color="#7fb800">get_weather</font>**(<font color="#00a6ed">**self**</font>)  Retrieves an object containing weather parameters currently active in the simulation, mainly cloudiness, precipitation, wind and sun position.      - **Return:** _[carla.WeatherParameters](#carla.WeatherParameters)_      - **Setter:** _[carla.World.set_weather](#carla.World.set_weather)_  
=====================================

h5: Setters
Contents:
- <a name="carla.World.set_pedestrians_cross_factor"></a>**<font color="#7fb800">set_pedestrians_cross_factor</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**percentage**</font>)      - **Parameters:**        - `percentage` (_float_) - Sets the percentage of pedestrians that can walk on the road or cross at any point on the road. Value should be between `0.0` and `1.0`. For example, a value of `0.1` would allow 10% of pedestrians to walk on the road. __Default is `0.0`__.      - **Note:** <font color="#8E8E8E">_Should be set before pedestrians are spawned._</font>  - <a name="carla.World.set_pedestrians_seed"></a>**<font color="#7fb800">set_pedestrians_seed</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**seed**</font>)      - **Parameters:**        - `seed` (_int_) - Sets the seed to use for any random number generated in relation to pedestrians.      - **Note:** <font color="#8E8E8E">_Should be set before pedestrians are spawned. If you want to repeat the same exact bodies (blueprint) for each pedestrian, then use the same seed in the Python code (where the blueprint is choosen randomly) and here, otherwise the pedestrians will repeat the same paths but the bodies will be different._</font>  - <a name="carla.World.set_weather"></a>**<font color="#7fb800">set_weather</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**weather**</font>)  Changes the weather parameteres ruling the simulation to another ones defined in an object.      - **Parameters:**        - `weather` (_[carla.WeatherParameters](#carla.WeatherParameters)_) - New conditions to be applied.      - **Getter:** _[carla.World.get_weather](#carla.World.get_weather)_  
=====================================

h5: Dunder methods
Contents:
- <a name="carla.WorldSnapshot.__eq__"></a>**<font color="#7fb800">\__eq__</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**other**=[carla.WorldSnapshot](#carla.WorldSnapshot)</font>)  Returns __True__ if both **<font color="#f8805a">timestamp</font>** are the same.      - **Return:** _bool_  - <a name="carla.WorldSnapshot.__iter__"></a>**<font color="#7fb800">\__iter__</font>**(<font color="#00a6ed">**self**</font>)  Iterate over the [carla.ActorSnapshot](#carla.ActorSnapshot) stored in the snapshot.  - <a name="carla.WorldSnapshot.__len__"></a>**<font color="#7fb800">\__len__</font>**(<font color="#00a6ed">**self**</font>)  Returns the amount of [carla.ActorSnapshot](#carla.ActorSnapshot) present in this snapshot.      - **Return:** _int_  - <a name="carla.WorldSnapshot.__ne__"></a>**<font color="#7fb800">\__ne__</font>**(<font color="#00a6ed">**self**</font>, <font color="#00a6ed">**other**=[carla.WorldSnapshot](#carla.WorldSnapshot)</font>)  Returns <b>True</b> if both **<font color="#f8805a">timestamp</font>** are different.      - **Return:** _bool_  ---
=====================================

h2: carla.ActorAttribute<a name="carla.ActorAttribute"></a>
Contents:
CARLA provides a library of blueprints for actors that can be accessed as [carla.BlueprintLibrary](#carla.BlueprintLibrary). Each of these blueprints has a series of attributes defined internally. Some of these are modifiable, others are not. A list of recommended values is provided for those that can be set.  
=====================================

h2: carla.ActorAttributeType<a name="carla.ActorAttributeType"></a>
Contents:
CARLA provides a library of blueprints for actors in [carla.BlueprintLibrary](#carla.BlueprintLibrary) with different attributes each. This class defines the types those at [carla.ActorAttribute](#carla.ActorAttribute) can be as a series of enum. All this information is managed internally and listed here for a better comprehension of how CARLA works.  
=====================================

h2: carla.ActorBlueprint<a name="carla.ActorBlueprint"></a>
Contents:
CARLA provides a blueprint library for actors that can be consulted through [carla.BlueprintLibrary](#carla.BlueprintLibrary). Each of these consists of an identifier for the blueprint and a series of attributes that may be modifiable or not. This class is the intermediate step between the library and the actor creation. Actors need an actor blueprint to be spawned. These store the information for said blueprint in an object with its attributes and some tags to categorize them. The user can then customize some attributes and eventually spawn the actors through [carla.World](#carla.World).  
=====================================

h2: carla.ActorList<a name="carla.ActorList"></a>
Contents:
A class that contains every actor present on the scene and provides access to them. The list is automatically created and updated by the server and it can be returned using [carla.World](#carla.World).  
=====================================

h2: carla.ActorSnapshot<a name="carla.ActorSnapshot"></a>
Contents:
A class that comprises all the information for an actor at a certain moment in time. These objects are contained in a [carla.WorldSnapshot](#carla.WorldSnapshot) and sent to the client once every tick.  
=====================================

h2: carla.AttachmentType<a name="carla.AttachmentType"></a>
Contents:
Class that defines attachment options between an actor and its parent. When spawning actors, these can be attached to another actor so their position changes accordingly. This is specially useful for sensors. The snipet in [carla.World.spawn_actor](#carla.World.spawn_actor) shows some sensors being attached to a car when spawned. Note that the attachment type is declared as an enum within the class.  
=====================================

h2: carla.BlueprintLibrary<a name="carla.BlueprintLibrary"></a>
Contents:
A class that contains the blueprints provided for actor spawning. Its main application is to return [carla.ActorBlueprint](#carla.ActorBlueprint) objects needed to spawn actors. Each blueprint has an identifier and attributes that may or may not be modifiable. The library is automatically created by the server and can be accessed through [carla.World](#carla.World).    [Here](bp_library.md) is a reference containing every available blueprint and its specifics.  
=====================================

h2: carla.BoundingBox<a name="carla.BoundingBox"></a>
Contents:
Bounding boxes contain the geometry of an actor or an element in the scene. They can be used by [carla.DebugHelper](#carla.DebugHelper) or a [carla.Client](#carla.Client) to draw their shapes for debugging. Check out the snipet in [carla.DebugHelper.draw_box](#carla.DebugHelper.draw_box) where a snapshot of the world is used to draw bounding boxes for traffic lights.  
=====================================

h2: carla.CityObjectLabel<a name="carla.CityObjectLabel"></a>
Contents:
Enum declaration that contains the different tags available to filter the bounding boxes returned by [carla.World.get_level_bbs](#carla.World.get_level_bbs)(). These values correspond to the [semantic tag](ref_sensors.md#semantic-segmentation-camera) that the elements in the scene have.  
=====================================

h2: carla.Client<a name="carla.Client"></a>
Contents:
The Client connects CARLA to the server which runs the simulation. Both server and client contain a CARLA library (libcarla) with some differences that allow communication between them. Many clients can be created and each of these will connect to the RPC server inside the simulation to send commands. The simulation runs server-side. Once the connection is established, the client will only receive data retrieved from the simulation. Walkers are the exception. The client is in charge of managing pedestrians so, if you are running a simulation with multiple clients, some issues may arise. For example, if you spawn walkers through different clients, collisions may happen, as each client is only aware of the ones it is in charge of.  The client also has a recording feature that saves all the information of a simulation while running it. This allows the server to replay it at will to obtain information and experiment with it. [Here](adv_recorder.md) is some information about how to use this recorder.  
=====================================

h2: carla.CollisionEvent<a name="carla.CollisionEvent"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.SensorData](#carla.SensorData)_</small></br>Class that defines a collision data for <b>sensor.other.collision</b>. The sensor creates one of this for every collision detected which may be many for one simulation step. Learn more about this [here](ref_sensors.md#collision-detector).  
=====================================

h2: carla.Color<a name="carla.Color"></a>
Contents:
Class that defines a 32-bit RGBA color.  
=====================================

h2: carla.ColorConverter<a name="carla.ColorConverter"></a>
Contents:
Class that defines conversion patterns that can be applied to a [carla.Image](#carla.Image) in order to show information provided by [carla.Sensor](#carla.Sensor). Depth conversions cause a loss of accuracy, as sensors detect depth as <b>float</b> that is then converted to a grayscale value between 0 and 255. Take a look at the snipet in [carla.Sensor.listen](#carla.Sensor.listen) to see an example of how to create and save image data for <b>sensor.camera.semantic_segmentation</b>.  
=====================================

h2: carla.DVSEvent<a name="carla.DVSEvent"></a>
Contents:
Class that defines a DVS event. An event is a quadruple, so a tuple of 4 elements, with `x`, `y` pixel coordinate location, timestamp `t` and polarity `pol` of the event. Learn more about them [here](ref_sensors.md).  
=====================================

h2: carla.DVSEventArray<a name="carla.DVSEventArray"></a>
Contents:
Class that defines a stream of events in [carla.DVSEvent](#carla.DVSEvent). Such stream is an array of arbitrary size depending on the number of events. This class also stores the field of view, the height and width of the image and the timestamp from convenience. Learn more about them [here](ref_sensors.md).  
=====================================

h2: carla.DebugHelper<a name="carla.DebugHelper"></a>
Contents:
Helper class part of [carla.World](#carla.World) that defines methods for creating debug shapes. By default, shapes last one second. They can be permanent, but take into account the resources needed to do so. Take a look at the snipets available for this class to learn how to debug easily in CARLA.  
=====================================

h2: carla.EnvironmentObject<a name="carla.EnvironmentObject"></a>
Contents:
Class that represents a geometry in the level, this geometry could be part of an actor formed with other EnvironmentObjects (ie: buildings).  
=====================================

h2: carla.FloatColor<a name="carla.FloatColor"></a>
Contents:
Class that defines a float RGBA color.  
=====================================

h2: carla.GBufferTextureID<a name="carla.GBufferTextureID"></a>
Contents:
Defines the identifiers of each GBuffer texture (See the method `[carla.Sensor.listen_to_gbuffer](#carla.Sensor.listen_to_gbuffer)`).  
=====================================

h2: carla.GearPhysicsControl<a name="carla.GearPhysicsControl"></a>
Contents:
Class that provides access to vehicle transmission details by defining a gear and when to run on it. This will be later used by [carla.VehiclePhysicsControl](#carla.VehiclePhysicsControl) to help simulate physics.  
=====================================

h2: carla.GeoLocation<a name="carla.GeoLocation"></a>
Contents:
Class that contains geographical coordinates simulated data. The [carla.Map](#carla.Map) can convert simulation locations by using the <b><georeference></b> tag in the OpenDRIVE file.  
=====================================

h2: carla.GnssMeasurement<a name="carla.GnssMeasurement"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.SensorData](#carla.SensorData)_</small></br>Class that defines the Gnss data registered by a <b>sensor.other.gnss</b>. It essentially reports its position with the position of the sensor and an OpenDRIVE geo-reference.  
=====================================

h2: carla.IMUMeasurement<a name="carla.IMUMeasurement"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.SensorData](#carla.SensorData)_</small></br>Class that defines the data registered by a <b>sensor.other.imu</b>, regarding the sensor's transformation according to the current [carla.World](#carla.World). It essentially acts as accelerometer, gyroscope and compass.  
=====================================

h2: carla.Image<a name="carla.Image"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.SensorData](#carla.SensorData)_</small></br>Class that defines an image of 32-bit BGRA colors that will be used as initial data retrieved by camera sensors. There are different camera sensors (currently three, RGB, depth and semantic segmentation) and each of these makes different use for the images. Learn more about them [here](ref_sensors.md).  
=====================================

h2: carla.Junction<a name="carla.Junction"></a>
Contents:
Class that embodies the intersections on the road described in the OpenDRIVE file according to OpenDRIVE 1.4 standards.  
=====================================

h2: carla.LabelledPoint<a name="carla.LabelledPoint"></a>
Contents:
Class that represent a position in space with a semantic label.  
=====================================

h2: carla.Landmark<a name="carla.Landmark"></a>
Contents:
Class that defines any type of traffic landmark or sign affecting a road. These class mediates between the [OpenDRIVE 1.4 standard](http://www.opendrive.org/docs/OpenDRIVEFormatSpecRev1.4H.pdf) definition of the landmarks and their representation in the simulation. This class retrieves all the information defining a landmark in OpenDRIVE and facilitates information about which lanes does it affect and when.Landmarks will be accessed by [carla.Waypoint](#carla.Waypoint) objects trying to retrieve the regulation of their lane. Therefore some attributes depend on the waypoint that is consulting the landmark and so, creating the object.  
=====================================

h2: carla.LandmarkOrientation<a name="carla.LandmarkOrientation"></a>
Contents:
Helper class to define the orientation of a landmark in the road. The definition is not directly translated from OpenDRIVE but converted for the sake of understanding.  
=====================================

h2: carla.LandmarkType<a name="carla.LandmarkType"></a>
Contents:
Helper class containing a set of commonly used landmark types as defined by the default country code in the [OpenDRIVE standard](http://opendrive.org/docs/OpenDRIVEFormatSpecRev1.5M.pdf) (Germany 2017).__[carla.Landmark](#carla.Landmark) does not reference this class__. The landmark type is a string that varies greatly depending on the country code being used. This class only makes it easier to manage some of the most commonly used in the default set by describing them as an enum.  
=====================================

h2: carla.LaneChange<a name="carla.LaneChange"></a>
Contents:
Class that defines the permission to turn either left, right, both or none (meaning only going straight is allowed). This information is stored for every [carla.Waypoint](#carla.Waypoint) according to the OpenDRIVE file. The snipet in [carla.Map.get_waypoint](#carla.Map.get_waypoint) shows how a waypoint can be used to learn which turns are permitted.  
=====================================

h2: carla.LaneInvasionEvent<a name="carla.LaneInvasionEvent"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.SensorData](#carla.SensorData)_</small></br>Class that defines lanes invasion for <b>sensor.other.lane_invasion</b>. It works only client-side and is dependant on OpenDRIVE to provide reliable information. The sensor creates one of this every time there is a lane invasion, which may be more than once per simulation step. Learn more about this [here](ref_sensors.md#lane-invasion-detector).  
=====================================

h2: carla.LaneMarking<a name="carla.LaneMarking"></a>
Contents:
Class that gathers all the information regarding a lane marking according to [OpenDRIVE 1.4 standard](http://www.opendrive.org/docs/OpenDRIVEFormatSpecRev1.4H.pdf) standard.  
=====================================

h2: carla.LaneMarkingColor<a name="carla.LaneMarkingColor"></a>
Contents:
Class that defines the lane marking colors according to OpenDRIVE 1.4.  
=====================================

h2: carla.LaneMarkingType<a name="carla.LaneMarkingType"></a>
Contents:
Class that defines the lane marking types accepted by OpenDRIVE 1.4. The snipet in [carla.Map.get_waypoint](#carla.Map.get_waypoint) shows how a waypoint can be used to retrieve the information about adjacent lane markings.   <br><br> __Note on double types:__ Lane markings are defined under the OpenDRIVE standard that determines whereas a line will be considered "BrokenSolid" or "SolidBroken". For each road there is a center lane marking, defined from left to right regarding the lane's directions. The rest of the lane markings are defined in order from the center lane to the closest outside of the road.  
=====================================

h2: carla.LaneType<a name="carla.LaneType"></a>
Contents:
Class that defines the possible lane types accepted by OpenDRIVE 1.4. This standards define the road information. The snipet in [carla.Map.get_waypoint](#carla.Map.get_waypoint) makes use of a waypoint to get the current and adjacent lane types.  
=====================================

h2: carla.LidarDetection<a name="carla.LidarDetection"></a>
Contents:
Data contained inside a [carla.LidarMeasurement](#carla.LidarMeasurement). Each of these represents one of the points in the cloud with its location and its asociated intensity.  
=====================================

h2: carla.LidarMeasurement<a name="carla.LidarMeasurement"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.SensorData](#carla.SensorData)_</small></br>Class that defines the LIDAR data retrieved by a <b>sensor.lidar.ray_cast</b>. This essentially simulates a rotating LIDAR using ray-casting. Learn more about this [here](ref_sensors.md#lidar-raycast-sensor).  
=====================================

h2: carla.Light<a name="carla.Light"></a>
Contents:
This class exposes the lights that exist in the scene, except for vehicle lights. The properties of a light can be queried and changed at will.Lights are automatically turned on when the simulator enters night mode (sun altitude is below zero).  
=====================================

h2: carla.LightGroup<a name="carla.LightGroup"></a>
Contents:
This class categorizes the lights on scene into different groups. These groups available are provided as a enum values that can be used as flags.  __Note.__ So far, though there is a `vehicle` group, vehicle lights are not available as [carla.Light](#carla.Light) objects. These have to be managed using [carla.Vehicle](#carla.Vehicle) and [carla.VehicleLightState](#carla.VehicleLightState).  
=====================================

h2: carla.LightManager<a name="carla.LightManager"></a>
Contents:
This class handles the lights in the scene. Its main use is to get and set the state of groups or lists of lights in one call. An instance of this class can be retrieved by the [carla.World.get_lightmanager](#carla.World.get_lightmanager)().  __Note.__ So far, though there is a `vehicle` group, vehicle lights are not available as [carla.Light](#carla.Light) objects. These have to be managed using [carla.Vehicle](#carla.Vehicle) and [carla.VehicleLightState](#carla.VehicleLightState).  
=====================================

h2: carla.LightState<a name="carla.LightState"></a>
Contents:
This class represents all the light variables except the identifier and the location, which are should to be static. Using this class allows to manage all the parametrization of the light in one call.  
=====================================

h2: carla.Location<a name="carla.Location"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.Vector3D](#carla.Vector3D)_</small></br>Represents a spot in the world.  
=====================================

h2: carla.Map<a name="carla.Map"></a>
Contents:
Class containing the road information and waypoint managing. Data is retrieved from an OpenDRIVE file that describes the road. A query system is defined which works hand in hand with [carla.Waypoint](#carla.Waypoint) to translate geometrical information from the .xodr to natural world points. CARLA is currently working with [OpenDRIVE 1.4 standard](http://www.opendrive.org/docs/OpenDRIVEFormatSpecRev1.4H.pdf).  
=====================================

h2: carla.MapLayer<a name="carla.MapLayer"></a>
Contents:
Class that represents each manageable layer of the map. Can be used as flags. __WARNING: Only "Opt" maps are able to work with map layers.__.  
=====================================

h2: carla.MaterialParameter<a name="carla.MaterialParameter"></a>
Contents:
Class that represents material parameters. Not all objects in the scene contain all parameters.  
=====================================

h2: carla.ObstacleDetectionEvent<a name="carla.ObstacleDetectionEvent"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.SensorData](#carla.SensorData)_</small></br>Class that defines the obstacle data for <b>sensor.other.obstacle</b>. Learn more about this [here](ref_sensors.md#obstacle-detector).  
=====================================

h2: carla.OpendriveGenerationParameters<a name="carla.OpendriveGenerationParameters"></a>
Contents:
This class defines the parameters used when generating a world using an OpenDRIVE file.  
=====================================

h2: carla.OpticalFlowImage<a name="carla.OpticalFlowImage"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.SensorData](#carla.SensorData)_</small></br>Class that defines an optical flow image of 2-Dimension float (32-bit) vectors representing the optical flow detected in the field of view. The components of the vector represents the displacement of an object in the image plane. Each component outputs values in the normalized range [-2,2] which scales to [-2 size, 2 size] with size being the total resolution in the corresponding component.  
=====================================

h2: carla.OpticalFlowPixel<a name="carla.OpticalFlowPixel"></a>
Contents:
Class that defines a 2 dimensional vector representing an optical flow pixel.  
=====================================

h2: carla.Osm2Odr<a name="carla.Osm2Odr"></a>
Contents:
Class that converts an OpenStreetMap map to OpenDRIVE format, so that it can be loaded in CARLA. Find out more about this feature in the [docs](tuto_G_openstreetmap.md).  
=====================================

h2: carla.Osm2OdrSettings<a name="carla.Osm2OdrSettings"></a>
Contents:
Helper class that contains the parameterization that will be used by [carla.Osm2Odr](#carla.Osm2Odr) to convert an OpenStreetMap map to OpenDRIVE format. Find out more about this feature in the [docs](tuto_G_openstreetmap.md).  
=====================================

h2: carla.RadarDetection<a name="carla.RadarDetection"></a>
Contents:
Data contained inside a [carla.RadarMeasurement](#carla.RadarMeasurement). Each of these represents one of the points in the cloud that a <b>sensor.other.radar</b> registers and contains the distance, angle and velocity in relation to the radar.  
=====================================

h2: carla.RadarMeasurement<a name="carla.RadarMeasurement"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.SensorData](#carla.SensorData)_</small></br>Class that defines and gathers the measures registered by a <b>sensor.other.radar</b>, representing a wall of points in front of the sensor with a distance, angle and velocity in relation to it. The data consists of a [carla.RadarDetection](#carla.RadarDetection) array. Learn more about this [here](ref_sensors.md#radar-sensor).  
=====================================

h2: carla.Rotation<a name="carla.Rotation"></a>
Contents:
Class that represents a 3D rotation and therefore, an orientation in space. CARLA uses the Unreal Engine coordinates system. This is a Z-up left-handed system.  <br><br>The constructor method follows a specific order of declaration: `(pitch, yaw, roll)`, which corresponds to `(Y-rotation,Z-rotation,X-rotation)`.  <br> <br>![UE4_Rotation](https://d26ilriwvtzlb.cloudfront.net/8/83/BRMC_9.jpg) *Unreal Engine's coordinates system*.  
=====================================

h2: carla.RssActorConstellationData<a name="carla.RssActorConstellationData"></a>
Contents:
Data structure that is provided within the callback registered by RssSensor.register_actor_constellation_callback().  
=====================================

h2: carla.RssActorConstellationResult<a name="carla.RssActorConstellationResult"></a>
Contents:
Data structure that should be returned by the callback registered by RssSensor.register_actor_constellation_callback().  
=====================================

h2: carla.RssEgoDynamicsOnRoute<a name="carla.RssEgoDynamicsOnRoute"></a>
Contents:
Part of the data contained inside a [carla.RssResponse](#carla.RssResponse) describing the state of the vehicle. The parameters include its current dynamics, and how it is heading regarding the target route.  
=====================================

h2: carla.RssLogLevel<a name="carla.RssLogLevel"></a>
Contents:
Enum declaration used in [carla.RssSensor](#carla.RssSensor) to set the log level.  
=====================================

h2: carla.RssResponse<a name="carla.RssResponse"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.SensorData](#carla.SensorData)_</small></br>Class that contains the output of a [carla.RssSensor](#carla.RssSensor). This is the result of the RSS calculations performed for the parent vehicle of the sensor.A [carla.RssRestrictor](#carla.RssRestrictor) will use the data to modify the [carla.VehicleControl](#carla.VehicleControl) of the vehicle.  
=====================================

h2: carla.RssRestrictor<a name="carla.RssRestrictor"></a>
Contents:
These objects apply restrictions to a [carla.VehicleControl](#carla.VehicleControl). It is part of the CARLA implementation of the [C++ Library for Responsibility Sensitive Safety](https://github.com/intel/ad-rss-lib). This class works hand in hand with a [rss sensor](ref_sensors.md#rss-sensor), which provides the data of the restrictions to be applied.  
=====================================

h2: carla.RssRoadBoundariesMode<a name="carla.RssRoadBoundariesMode"></a>
Contents:
Enum declaration used in [carla.RssSensor](#carla.RssSensor) to enable or disable the [stay on road](https://intel.github.io/ad-rss-lib/ad_rss_map_integration/HandleRoadBoundaries/) feature. In summary, this feature considers the road boundaries as virtual objects. The minimum safety distance check is applied to these virtual walls, in order to make sure the vehicle does not drive off the road.  
=====================================

h2: carla.RssSensor<a name="carla.RssSensor"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.Sensor](#carla.Sensor)_</small></br>This sensor works a bit differently than the rest. Take look at the [specific documentation](adv_rss.md), and the [rss sensor reference](ref_sensors.md#rss-sensor) to gain full understanding of it.The RSS sensor uses world information, and a [RSS library](https://github.com/intel/ad-rss-lib) to make safety checks on a vehicle. The output retrieved by the sensor is a [carla.RssResponse](#carla.RssResponse). This will be used by a [carla.RssRestrictor](#carla.RssRestrictor) to modify a [carla.VehicleControl](#carla.VehicleControl) before applying it to a vehicle.  
=====================================

h2: carla.SemanticLidarDetection<a name="carla.SemanticLidarDetection"></a>
Contents:
Data contained inside a [carla.SemanticLidarMeasurement](#carla.SemanticLidarMeasurement). Each of these represents one of the points in the cloud with its location, the cosine of the incident angle, index of the object hit, and its semantic tag.  
=====================================

h2: carla.SemanticLidarMeasurement<a name="carla.SemanticLidarMeasurement"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.SensorData](#carla.SensorData)_</small></br>Class that defines the semantic LIDAR data retrieved by a <b>sensor.lidar.ray_cast_semantic</b>. This essentially simulates a rotating LIDAR using ray-casting. Learn more about this [here](ref_sensors.md#semanticlidar-raycast-sensor).  
=====================================

h2: carla.Sensor<a name="carla.Sensor"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.Actor](#carla.Actor)_</small></br>Sensors compound a specific family of actors quite diverse and unique. They are normally spawned as attachment/sons of a vehicle (take a look at [carla.World](#carla.World) to learn about actor spawning). Sensors are thoroughly designed to retrieve different types of data that they are listening to. The data they receive is shaped as different subclasses inherited from [carla.SensorData](#carla.SensorData) (depending on the sensor).  Most sensors can be divided in two groups: those receiving data on every tick (cameras, point clouds and some specific sensors) and those who only receive under certain circumstances (trigger detectors). CARLA provides a specific set of sensors and their blueprint can be found in [carla.BlueprintLibrary](#carla.BlueprintLibrary). All the information on their preferences and settlement can be found [here](ref_sensors.md), but the list of those available in CARLA so far goes as follow.  <br><b>Receive data on every tick.</b>  - [Depth camera](ref_sensors.md#depth-camera).  - [Gnss sensor](ref_sensors.md#gnss-sensor).  - [IMU sensor](ref_sensors.md#imu-sensor).  - [Lidar raycast](ref_sensors.md#lidar-raycast-sensor).  - [SemanticLidar raycast](ref_sensors.md#semanticlidar-raycast-sensor).  - [Radar](ref_sensors.md#radar-sensor).  - [RGB camera](ref_sensors.md#rgb-camera).  - [RSS sensor](ref_sensors.md#rss-sensor).  - [Semantic Segmentation camera](ref_sensors.md#semantic-segmentation-camera).  <br><b>Only receive data when triggered.</b>  - [Collision detector](ref_sensors.md#collision-detector).  - [Lane invasion detector](ref_sensors.md#lane-invasion-detector).  - [Obstacle detector](ref_sensors.md#obstacle-detector).  
=====================================

h2: carla.SensorData<a name="carla.SensorData"></a>
Contents:
Base class for all the objects containing data generated by a [carla.Sensor](#carla.Sensor). This objects should be the argument of the function said sensor is listening to, in order to work with them. Each of these sensors needs for a specific type of sensor data. Hereunder is a list of the sensors and their corresponding data.<br>  - Cameras (RGB, depth and semantic segmentation): [carla.Image](#carla.Image).<br>  - Collision detector: [carla.CollisionEvent](#carla.CollisionEvent).<br>  - GNSS sensor: [carla.GnssMeasurement](#carla.GnssMeasurement).<br>  - IMU sensor: [carla.IMUMeasurement](#carla.IMUMeasurement).<br>  - Lane invasion detector: [carla.LaneInvasionEvent](#carla.LaneInvasionEvent).<br>  - LIDAR sensor: [carla.LidarMeasurement](#carla.LidarMeasurement).<br>  - Obstacle detector: [carla.ObstacleDetectionEvent](#carla.ObstacleDetectionEvent).<br>  - Radar sensor: [carla.RadarMeasurement](#carla.RadarMeasurement).<br>  - RSS sensor: [carla.RssResponse](#carla.RssResponse).<br>  - Semantic LIDAR sensor: [carla.SemanticLidarMeasurement](#carla.SemanticLidarMeasurement).  
=====================================

h2: carla.TextureColor<a name="carla.TextureColor"></a>
Contents:
Class representing a texture object to be uploaded to the server. Pixel format is RGBA, uint8 per channel.  
=====================================

h2: carla.TextureFloatColor<a name="carla.TextureFloatColor"></a>
Contents:
Class representing a texture object to be uploaded to the server. Pixel format is RGBA, float per channel.  
=====================================

h2: carla.Timestamp<a name="carla.Timestamp"></a>
Contents:
Class that contains time information for simulated data. This information is automatically retrieved as part of the [carla.WorldSnapshot](#carla.WorldSnapshot) the client gets on every frame, but might also be used in many other situations such as a [carla.Sensor](#carla.Sensor) retrieveing data.  
=====================================

h2: carla.TrafficLight<a name="carla.TrafficLight"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.TrafficSign](#carla.TrafficSign)_</small></br>A traffic light actor, considered a specific type of traffic sign. As traffic lights will mostly appear at junctions, they belong to a group which contains the different traffic lights in it. Inside the group, traffic lights are differenciated by their pole index.       Within a group the state of traffic lights is changed in a cyclic pattern: one index is chosen and it spends a few seconds in green, yellow and eventually red. The rest of the traffic lights remain frozen in red this whole time, meaning that there is a gap in the last seconds of the cycle where all the traffic lights are red. However, the state of a traffic light can be changed manually.  
=====================================

h2: carla.TrafficLightState<a name="carla.TrafficLightState"></a>
Contents:
All possible states for traffic lights. These can either change at a specific time step or be changed manually. The snipet in [carla.TrafficLight.set_state](#carla.TrafficLight.set_state) changes the state of a traffic light on the fly.  
=====================================

h2: carla.TrafficManager<a name="carla.TrafficManager"></a>
Contents:
The traffic manager is a module built on top of the CARLA API in C++. It handles any group of vehicles set to autopilot mode to populate the simulation with realistic urban traffic conditions and give the chance to user to customize some behaviours. The architecture of the traffic manager is divided in five different goal-oriented stages and a PID controller where the information flows until eventually, a [carla.VehicleControl](#carla.VehicleControl) is applied to every vehicle registered in a traffic manager.In order to learn more, visit the [documentation](adv_traffic_manager.md) regarding this module.  
=====================================

h2: carla.TrafficSign<a name="carla.TrafficSign"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.Actor](#carla.Actor)_</small></br>Traffic signs appearing in the simulation except for traffic lights. These have their own class inherited from this in [carla.TrafficLight](#carla.TrafficLight). Right now, speed signs, stops and yields are mainly the ones implemented, but many others are borne in mind.  
=====================================

h2: carla.Transform<a name="carla.Transform"></a>
Contents:
Class that defines a transformation, a combination of location and rotation, without scaling.  
=====================================

h2: carla.Vector2D<a name="carla.Vector2D"></a>
Contents:
Helper class to perform 2D operations.  
=====================================

h2: carla.Vector3D<a name="carla.Vector3D"></a>
Contents:
Helper class to perform 3D operations.  
=====================================

h2: carla.Vehicle<a name="carla.Vehicle"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.Actor](#carla.Actor)_</small></br>One of the most important group of actors in CARLA. These include any type of vehicle from cars to trucks, motorbikes, vans, bycicles and also official vehicles such as police cars. A wide set of these actors is provided in [carla.BlueprintLibrary](#carla.BlueprintLibrary) to facilitate differente requirements. Vehicles can be either manually controlled or set to an autopilot mode that will be conducted client-side by the <b>traffic manager</b>.  
=====================================

h2: carla.VehicleControl<a name="carla.VehicleControl"></a>
Contents:
Manages the basic movement of a vehicle using typical driving controls.  
=====================================

h2: carla.VehicleDoor<a name="carla.VehicleDoor"></a>
Contents:
Possible index representing the possible doors that can be open. Notice that not all possible doors are able to open in some vehicles.  
=====================================

h2: carla.VehicleFailureState<a name="carla.VehicleFailureState"></a>
Contents:
Enum containing the different failure states of a vehicle, from which the it cannot recover. These are returned by __<font color="#7fb800">get_failure_state()</font>__ and only Rollover is currently implemented.  
=====================================

h2: carla.VehicleLightState<a name="carla.VehicleLightState"></a>
Contents:
Class that recaps the state of the lights of a vehicle, these can be used as a flags. E.g: `VehicleLightState.HighBeam & VehicleLightState.Brake` will return `True` when both are active. Lights are off by default in any situation and should be managed by the user via script. The blinkers blink automatically. _Warning: Right now, not all vehicles have been prepared to work with this functionality, this will be added to all of them in later updates_.  
=====================================

h2: carla.VehiclePhysicsControl<a name="carla.VehiclePhysicsControl"></a>
Contents:
Summarizes the parameters that will be used to simulate a [carla.Vehicle](#carla.Vehicle) as a physical object. The specific settings for the wheels though are stipulated using [carla.WheelPhysicsControl](#carla.WheelPhysicsControl).  
=====================================

h2: carla.VehicleWheelLocation<a name="carla.VehicleWheelLocation"></a>
Contents:
`enum` representing the position of each wheel on a vehicle.  Used to identify the target wheel when setting an angle in [carla.Vehicle.set_wheel_steer_direction](#carla.Vehicle.set_wheel_steer_direction) or [carla.Vehicle.get_wheel_steer_angle](#carla.Vehicle.get_wheel_steer_angle).  
=====================================

h2: carla.Walker<a name="carla.Walker"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.Actor](#carla.Actor)_</small></br>This class inherits from the [carla.Actor](#carla.Actor) and defines pedestrians in the simulation. Walkers are a special type of actor that can be controlled either by an AI ([carla.WalkerAIController](#carla.WalkerAIController)) or manually via script, using a series of [carla.WalkerControl](#carla.WalkerControl) to move these and their skeletons.  
=====================================

h2: carla.WalkerAIController<a name="carla.WalkerAIController"></a>
Contents:
<small style="display:block;margin-top:-20px;">Inherited from _[carla.Actor](#carla.Actor)_</small></br>Class that conducts AI control for a walker. The controllers are defined as actors, but they are quite different from the rest. They need to be attached to a parent actor during their creation, which is the walker they will be controlling (take a look at [carla.World](#carla.World) if you are yet to learn on how to spawn actors). They also need for a special blueprint (already defined in [carla.BlueprintLibrary](#carla.BlueprintLibrary) as "controller.ai.walker"). This is an empty blueprint, as the AI controller will be invisible in the simulation but will follow its parent around to dictate every step of the way.  
=====================================

h2: carla.WalkerBoneControlIn<a name="carla.WalkerBoneControlIn"></a>
Contents:
This class grants bone specific manipulation for walker. The skeletons of walkers have been unified for clarity and the transform applied to each bone are always relative to its parent. Take a look [here](tuto_G_control_walker_skeletons.md) to learn more on how to create a walker and define its movement.  
=====================================

h2: carla.WalkerBoneControlOut<a name="carla.WalkerBoneControlOut"></a>
Contents:
This class is used to return all bone positions of a pedestrian. For each bone we get its _name_ and its transform in three different spaces (world, actor and relative).  
=====================================

h2: carla.WalkerControl<a name="carla.WalkerControl"></a>
Contents:
This class defines specific directions that can be commanded to a [carla.Walker](#carla.Walker) to control it via script.    AI control can be settled for walkers, but the control used to do so is [carla.WalkerAIController](#carla.WalkerAIController).  
=====================================

h2: carla.Waypoint<a name="carla.Waypoint"></a>
Contents:
Waypoints in CARLA are described as 3D directed points. They have a [carla.Transform](#carla.Transform) which locates the waypoint in a road and orientates it according to the lane. They also store the road information belonging to said point regarding its lane and lane markings.   <br><br> All the information regarding waypoints and the [waypoint API](../../core_map/#navigation-in-carla) is retrieved as provided by the OpenDRIVE file. Once the client asks for the map object to the server, no longer communication will be needed.  
=====================================

h2: carla.WeatherParameters<a name="carla.WeatherParameters"></a>
Contents:
This class defines objects containing lighting and weather specifications that can later be applied in [carla.World](#carla.World). So far, these conditions only intervene with [sensor.camera.rgb](ref_sensors.md#rgb-camera). They neither affect the actor's physics nor other sensors.          Each of these parameters acts indepently from the rest. Increasing the rainfall will not automatically create puddles nor change the road's humidity. That makes for a better customization but means that realistic conditions need to be scripted. However an example of dynamic weather conditions working realistically can be found [here](https://github.com/carla-simulator/carla/blob/master/PythonAPI/examples/dynamic_weather.py).  
=====================================

h2: carla.WheelPhysicsControl<a name="carla.WheelPhysicsControl"></a>
Contents:
Class that defines specific physical parameters for wheel objects that will be part of a [carla.VehiclePhysicsControl](#carla.VehiclePhysicsControl) to simulate vehicle it as a material object.  
=====================================

h2: carla.World<a name="carla.World"></a>
Contents:
World objects are created by the client to have a place for the simulation to happen. The world contains the map we can see, meaning the asset, not the navigation map. Navigation maps are part of the [carla.Map](#carla.Map) class. It also manages the weather and actors present in it. There can only be one world per simulation, but it can be changed anytime.  
=====================================

h2: carla.WorldSettings<a name="carla.WorldSettings"></a>
Contents:
The simulation has some advanced configuration options that are contained in this class and can be managed using [carla.World](#carla.World) and its methods. These allow the user to choose between client-server synchrony/asynchrony, activation of "no rendering mode" and either if the simulation should run with a fixed or variable time-step. Check [this](adv_synchrony_timestep.md) out if you want to learn about it.  
=====================================

h2: carla.WorldSnapshot<a name="carla.WorldSnapshot"></a>
Contents:
This snapshot comprises all the information for every actor on scene at a certain moment of time. It creates and gives acces to a data structure containing a series of [carla.ActorSnapshot](#carla.ActorSnapshot). The client recieves a new snapshot on every tick that cannot be stored.  
=====================================

h2: command.ApplyAngularImpulse<a name="command.ApplyAngularImpulse"></a>
Contents:
Command adaptation of __<font color="#7fb800">add_angular_impulse()</font>__ in [carla.Actor](#carla.Actor). Applies an angular impulse to an actor.  
=====================================

h2: command.ApplyForce<a name="command.ApplyForce"></a>
Contents:
Command adaptation of __<font color="#7fb800">add_force()</font>__ in [carla.Actor](#carla.Actor). Applies a force to an actor.  
=====================================

h2: command.ApplyImpulse<a name="command.ApplyImpulse"></a>
Contents:
Command adaptation of __<font color="#7fb800">add_impulse()</font>__ in [carla.Actor](#carla.Actor). Applies an impulse to an actor.  
=====================================

h2: command.ApplyTargetAngularVelocity<a name="command.ApplyTargetAngularVelocity"></a>
Contents:
Command adaptation of __<font color="#7fb800">set_target_angular_velocity()</font>__ in [carla.Actor](#carla.Actor). Sets the actor's angular velocity vector.  
=====================================

h2: command.ApplyTargetVelocity<a name="command.ApplyTargetVelocity"></a>
Contents:
Command adaptation of __<font color="#7fb800">set_target_velocity()</font>__ in [carla.Actor](#carla.Actor).  
=====================================

h2: command.ApplyTorque<a name="command.ApplyTorque"></a>
Contents:
Command adaptation of __<font color="#7fb800">add_torque()</font>__ in [carla.Actor](#carla.Actor). Applies a torque to an actor.  
=====================================

h2: command.ApplyTransform<a name="command.ApplyTransform"></a>
Contents:
Command adaptation of __<font color="#7fb800">set_transform()</font>__ in [carla.Actor](#carla.Actor). Sets a new transform to an actor.  
=====================================

h2: command.ApplyVehicleControl<a name="command.ApplyVehicleControl"></a>
Contents:
Command adaptation of __<font color="#7fb800">apply_control()</font>__ in [carla.Vehicle](#carla.Vehicle). Applies a certain control to a vehicle.  
=====================================

h2: command.ApplyVehiclePhysicsControl<a name="command.ApplyVehiclePhysicsControl"></a>
Contents:
Command adaptation of __<font color="#7fb800">apply_physics_control()</font>__ in [carla.Vehicle](#carla.Vehicle). Applies a new physics control to a vehicle, modifying its physical parameters.  
=====================================

h2: command.ApplyWalkerControl<a name="command.ApplyWalkerControl"></a>
Contents:
Command adaptation of __<font color="#7fb800">apply_control()</font>__ in [carla.Walker](#carla.Walker). Applies a control to a walker.  
=====================================

h2: command.ApplyWalkerState<a name="command.ApplyWalkerState"></a>
Contents:
Apply a state to the walker actor. Specially useful to initialize an actor them with a specific location, orientation and speed.  
=====================================

h2: command.DestroyActor<a name="command.DestroyActor"></a>
Contents:
Command adaptation of __<font color="#7fb800">destroy()</font>__ in [carla.Actor](#carla.Actor) that tells the simulator to destroy this actor. It has no effect if the actor was already destroyed. When executed with __<font color="#7fb800">apply_batch_sync()</font>__ in [carla.Client](#carla.Client) there will be a <b>command.Response</b> that will return a boolean stating whether the actor was successfully destroyed.  
=====================================

h2: command.Response<a name="command.Response"></a>
Contents:
States the result of executing a command as either the ID of the actor to whom the command was applied to (when succeeded) or an error string (when failed).  actor ID, depending on whether or not the command succeeded. The method __<font color="#7fb800">apply_batch_sync()</font>__ in [carla.Client](#carla.Client) returns a list of these to summarize the execution of a batch.  
=====================================

h2: command.SetAutopilot<a name="command.SetAutopilot"></a>
Contents:
Command adaptation of __<font color="#7fb800">set_autopilot()</font>__ in [carla.Vehicle](#carla.Vehicle). Turns on/off the vehicle's autopilot mode.  
=====================================

h2: command.SetEnableGravity<a name="command.SetEnableGravity"></a>
Contents:
Command adaptation of __<font color="#7fb800">set_enable_gravity()</font>__ in [carla.Actor](#carla.Actor). Enables or disables gravity on an actor.  
=====================================

h2: command.SetSimulatePhysics<a name="command.SetSimulatePhysics"></a>
Contents:
Command adaptation of __<font color="#7fb800">set_simulate_physics()</font>__ in [carla.Actor](#carla.Actor). Determines whether an actor will be affected by physics or not.  
=====================================

h2: command.SetVehicleLightState<a name="command.SetVehicleLightState"></a>
Contents:
Command adaptation of __<font color="#7fb800">set_light_state()</font>__ in [carla.Vehicle](#carla.Vehicle). Sets the light state of a vehicle.  
=====================================

h2: command.ShowDebugTelemetry<a name="command.ShowDebugTelemetry"></a>
Contents:
Command adaptation of __<font color="#7fb800">show_debug_telemetry()</font>__ in [carla.Actor](#carla.Actor). Displays vehicle control telemetry data.  
=====================================

h2: command.SpawnActor<a name="command.SpawnActor"></a>
Contents:
Command adaptation of __<font color="#7fb800">spawn_actor()</font>__ in [carla.World](#carla.World). Spawns an actor into the world based on the blueprint provided and the transform. If a parent is provided, the actor is attached to it.  
=====================================

