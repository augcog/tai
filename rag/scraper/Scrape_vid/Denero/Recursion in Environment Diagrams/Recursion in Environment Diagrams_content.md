# "Understanding Recursive Functions with Environment Diagrams: A Factorial Example"

##  Let's talk about recursion in environment diagrams. The nice thing is that environment diagrams are useful for understanding recursive functions. So we're going to look at a new example, the factorial function, which computes the factorial of n, or n times n minus 1, times n minus 2, times n minus 3, all the way down until you get to 1. We'll start out by looking at the Python tutor itself.

# "Implementing the Factorial Function Using Recursion"

##  So here is an implementation. Define the factorial of n to be. Well, if n is 0, we return 1. That's part of the definition of factorial that 0 factorial is 1. Otherwise, return n times the factorial of n minus 1. There's our recursive call. And finally, we're going to call factorial on 3, which should give us 3 times 2 times 1, and we'll be done. Okay, so first I define the function, and then I call it, on the argument 3. 3 is not 0. So I evaluate n times factorial of n minus 1. So we need to figure out one of these two things we're multiplying together, which involves computing factorial of n minus 1, where n minus 1 is 2. So I make another call to factorial, this time with n being bound to 2, because that's the argument that I pass it. And I execute the body again. This time in a new environment, where n is bound to 2. 2 is not 0, and so we evaluate n times factorial of n minus 1 again. But in this environment, n minus 1 is the number 1, which means our next call to factorial will have a different number bound to n. So now we have 1, 2, 3 calls to factorial. Might we get another? Well, let's see. That involves executing the body of factorial or fact one more time. Okay, so we execute fact. We see if 1 equals 0. It doesn't. So we have to execute this return statement one more time, which means evaluating fact n minus 1. What's n minus 1 at this point? Well, that's 0. And so we call fact on 0. One more time, we execute the body of this function, and cf0 equals 0. Aha, it does. And so we return the number 1. And now finally we have a return value. Now what happens when we return? Well, we return back to the line that we were evaluating when we made this function call in the first place, which was this factorial n minus 1 back when f3 was the first frame of the current environment. And what we found out is that fact n minus 1 in that frame had a return value of 1. Okay, now we find that there's a return value of 1 for this frame as well, because n is 1, and this evaluated to 1, and 1 times 1 is 1. So we return that to wherever we were when we called this function in the first place, which by the way was in the middle of executing the return statement in the f2 frame, which it was again inside the same body. And it was again evaluating this expression that I have highlighted, which now has a return value of 1. We multiplied n equals 2 times the return value of fact n minus 1, which was 1, and 2 times 1 is 2. So that's our return value. So we return 2 exactly to the same place, but in a different frame. Back when we were executing the return statement of the original call to fact. In that case, we were multiplying 3 times whatever we got here, which was this return value, and 3 times 2 is 6. And so we get 6 for the entire return value of fact 3, which is actually the right answer. 3 times 2 times 1 is 6.

# "Understanding Recursive Functions: Frames, Environments, and Evaluation"

##  So somewhere in the middle of execution, our environment diagram looked like this. At this point, we're returning from the last call to fact, but we haven't returned from these yet. Let's just analyze some properties of what happens when you call a recursive function. Well, the same function is called multiple times, as we can see. One call is from here. Several different calls came from here. So this one was from here. But all of these, F2, F3, and F4 frames, came from calling fact from within fact. Different frames are there in order to keep track of the different arguments in each call. So this is why we're able to call a function multiple times, with multiple different arguments, even one within the other, and the computer doesn't get confused, because it has this model of evaluation, where we have different frames holding the different argument values that were passed in. What n evaluates to depends upon which is the current environment. So there are all these different ends. Each corresponding to a different call to the fact function, and that means that every expression that has an n in it, might evaluate to a different thing, depending on which environment I'm in. And each call to fact solves a simpler problem than the last. In this case, because n keeps decreasing, and once n gets to zero, then we have a really simple computation. We just return one. So there's less work to do when we have n is to zero, then there is when we have n is one, and that's less work than when n is two, that's less work than when n is three.

# "Comparing Iteration and Recursion: Factorial Function Examples"

##  Now we can compare what happens when you have iteration versus recursion. So iteration is a special case of recursion. And here's our factorial function, here's what it does, and here's another implementation, using a wild statement instead of recursion. So I could say, I can compute the factorial event by keeping track of the total factorial, and what number I'm about to multiply in, and as long as k is less than or equal to n, I change total to be total times the next number that I multiply in, and I change k to be one more than it was before. And when I'm finished with this wild statement, then total will be bound to n factorial. So k was one, and then two, and then three, and then four, and we multiplied all those in. Using recursion, we say something a little bit simpler. We say the factorial event is one, if n is zero, otherwise it's n times factorial n minus one. Now, it not only took me less time to explain that, but it was easier to write in terms of the number of characters, and perhaps the logic is easier to follow if somebody else comes along and reads the function. So there are certainly cases where recursion just simplifies things, and I think this is one of them. Now, the mathematical formula that corresponds to each of these implementations is a bit different. So the iterative version says I start with k is one, and then I go up to n, and I multiply in the number k each time, but that's how I get n factorial. That exclamation mark means factorial. The recursive definition corresponds to a mathematical expression that looks like n factorial is one, if n is zero, or n times n minus one factorial, otherwise, which is also a correct definition of factorial, just looks a little bit different than that. So this one corresponds exactly to that. This one corresponds to this as well, but there's a little bit of extra machinery in here to keep track of the total, and make sure that we're multiplying in each piece correctly, and then returning the right thing at the end. Now, we can see that extra complexity in fact, iter versus our original definition using recursion, just by looking at all the names that are involved. So we have the name n, the name total, the name k, and the name fact iter, whereas in recursion we only have two names, and it's up to the frames in the environment diagram to keep track of where we are in the computation. Whereas on the left, we have to do that by keeping track of total and keeping track of k.

