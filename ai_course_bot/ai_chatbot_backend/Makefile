.PHONY: help install dev test lint format clean
.PHONY: add add-dev remove update show export
.PHONY: server db-init db-status admin test-api
.PHONY: docker-build docker-run

# Poetry with local virtual environment
POETRY = poetry
PYTHON = python
PIP = $(POETRY) run pip
PYTEST = $(POETRY) run pytest

# Default target
help: ## Show this help message
	@echo "TAI Backend Service - Poetry + Local .venv"
	@echo "=========================================="
	@echo ""
	@echo "ðŸš€ Quick Start:"
	@echo "  make install     # Install dependencies with Poetry"
	@echo "  make dev         # Start development server"
	@echo ""
	@echo "ðŸ“¦ Setup Commands:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST) | grep -E "(install|setup)"
	@echo ""
	@echo "ðŸ› ï¸  Development Commands:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST) | grep -E "(dev|server|test|lint|format)"
	@echo ""
	@echo "ðŸ—„ï¸  Database Commands:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST) | grep -E "(db-|admin)"
	@echo ""
	@echo "ðŸ“¦ Package Management:"
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST) | grep -E "(add|remove|update|show)"
	@echo ""
	@echo "ðŸ’¡ Examples:"
	@echo "  make add PKG=torch              # Add production dependency"
	@echo "  make add-dev PKG=pytest         # Add development dependency"
	@echo "  make remove PKG=outdated-pkg    # Remove dependency"
	@echo ""

# Installation and setup
install: ## Install all dependencies with Poetry in local .venv
	@echo "ðŸ“¦ Installing dependencies with Poetry..."
	@echo "ðŸ”§ Configuring Poetry to use local virtual environment..."
	$(POETRY) config virtualenvs.in-project true
	$(POETRY) config virtualenvs.create true
	@echo "ðŸ“¦ Installing dependencies..."
	$(POETRY) install
	@echo "âœ… Dependencies installed in $(shell pwd)/.venv"
	@echo "ðŸ“ Virtual environment: $(shell $(POETRY) env info --path)"

install-dev: ## Install with development dependencies
	@echo "ðŸ“¦ Installing with development dependencies..."
	$(POETRY) config virtualenvs.in-project true
	$(POETRY) config virtualenvs.create true
	$(POETRY) install --with dev
	@echo "âœ… Development environment ready!"

# Development server
dev: server ## Start development server (alias for server)

server: ## Start the FastAPI development server
	@echo "ðŸš€ Starting TAI Backend Server..."
	@echo "ðŸ“ Server will be available at: http://localhost:8000"
	@echo "ðŸ“š API Documentation: http://localhost:8000/docs"
	@echo "ðŸ”§ Admin Interface: http://localhost:8000/admin"
	@echo ""
	$(PYTHON) main.py

# Database operations
db-init: ## Initialize database and import files
	@echo "ðŸ—„ï¸  Initializing database..."
	$(PYTHON) scripts/initialize_db_and_files.py
	@echo "âœ… Database initialized!"

db-status: ## Check database status
	@echo "ðŸ—„ï¸  Checking database status..."
	@curl -s http://localhost:8000/database-status 2>/dev/null || echo "âŒ Server not running. Start with 'make dev'"

admin: ## Open admin interface (server must be running)
	@echo "ðŸ”§ Opening admin interface..."
	@echo "Visit: http://localhost:8000/admin"
	@command -v open >/dev/null 2>&1 && open http://localhost:8000/admin || echo "Manual: http://localhost:8000/admin"

# Testing
test: ## Run all tests
	@echo "ðŸ§ª Running backend tests..."
	$(PYTEST) -v tests/

test-unit: ## Run unit tests only
	@echo "ðŸ§ª Running unit tests..."
	$(PYTEST) -v -m "unit" tests/

test-integration: ## Run integration tests only
	@echo "ðŸ§ª Running integration tests..."
	$(PYTEST) -v -m "integration" tests/

test-api: ## Run API tests only
	@echo "ðŸ§ª Running API tests..."
	$(PYTEST) -v -m "api" tests/

test-cov: ## Run tests with coverage report
	@echo "ðŸ§ª Running tests with coverage..."
	$(PYTEST) --cov=app --cov-report=html --cov-report=term-missing tests/

test-watch: ## Run tests in watch mode
	@echo "ðŸ§ª Running tests in watch mode..."
	$(PYTEST) -f tests/

# Code quality
lint: ## Run linting checks
	@echo "ðŸ” Running linting checks..."
	$(POETRY) run ruff check .
	$(POETRY) run mypy app --ignore-missing-imports
	@echo "âœ… Linting completed!"

lint-fix: ## Run linting with auto-fix
	@echo "ðŸ” Running linting with auto-fix..."
	$(POETRY) run ruff check --fix .
	$(POETRY) run ruff format .

format: ## Format code
	@echo "ðŸŽ¨ Formatting code..."
	$(POETRY) run black .
	$(POETRY) run ruff format .
	@echo "âœ… Code formatted!"

type-check: ## Run type checking
	@echo "ðŸ” Running type checks..."
	$(POETRY) run mypy app --ignore-missing-imports

# Package management with Poetry
add: ## Add production dependency (use: make add PKG=package-name)
	@if [ -z "$(PKG)" ]; then echo "âŒ Usage: make add PKG=package-name"; exit 1; fi
	@echo "ðŸ“¦ Adding package $(PKG) with Poetry..."
	$(POETRY) add $(PKG)
	@echo "âœ… Package $(PKG) added and pyproject.toml updated!"

add-dev: ## Add development dependency (use: make add-dev PKG=package-name)
	@if [ -z "$(PKG)" ]; then echo "âŒ Usage: make add-dev PKG=package-name"; exit 1; fi
	@echo "ðŸ“¦ Adding development package $(PKG) with Poetry..."
	$(POETRY) add --group dev $(PKG)
	@echo "âœ… Development package $(PKG) added!"

remove: ## Remove dependency (use: make remove PKG=package-name)
	@if [ -z "$(PKG)" ]; then echo "âŒ Usage: make remove PKG=package-name"; exit 1; fi
	@echo "ðŸ“¦ Removing package $(PKG) with Poetry..."
	$(POETRY) remove $(PKG)
	@echo "âœ… Package $(PKG) removed and pyproject.toml updated!"

update: ## Update all dependencies
	@echo "â¬†ï¸  Updating dependencies with Poetry..."
	$(POETRY) update
	@echo "âœ… Dependencies updated and poetry.lock refreshed!"

update-pkg: ## Update specific package (use: make update-pkg PKG=package-name)
	@if [ -z "$(PKG)" ]; then echo "âŒ Usage: make update-pkg PKG=package-name"; exit 1; fi
	@echo "â¬†ï¸  Updating package $(PKG) with Poetry..."
	$(POETRY) update $(PKG)
	@echo "âœ… Package $(PKG) updated!"

show: ## Show package info (use: make show PKG=package-name)
	@if [ -z "$(PKG)" ]; then \
		echo "ðŸ“Š Showing all dependencies:"; \
		$(POETRY) show; \
	else \
		echo "ðŸ“Š Showing package info: $(PKG)"; \
		$(POETRY) show $(PKG); \
	fi

show-tree: ## Show dependency tree
	@echo "ðŸ“Š Dependency tree:"
	$(POETRY) show --tree

export: ## Export requirements.txt for deployment
	@echo "ðŸ“¦ Exporting requirements.txt with Poetry..."
	$(POETRY) export --format=requirements.txt --output=requirements.txt --without-hashes
	@echo "âœ… requirements.txt generated from pyproject.toml!"

lock: ## Update poetry.lock file
	@echo "ðŸ”’ Updating poetry.lock..."
	$(POETRY) lock
	@echo "âœ… Lock file updated!"

# Maintenance
clean: ## Clean build artifacts and cache
	@echo "ðŸ§¹ Cleaning build artifacts..."
	@find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
	@find . -type d -name ".pytest_cache" -exec rm -rf {} + 2>/dev/null || true
	@find . -type d -name ".mypy_cache" -exec rm -rf {} + 2>/dev/null || true
	@find . -type d -name "*.egg-info" -exec rm -rf {} + 2>/dev/null || true
	@find . -type f -name "*.pyc" -delete 2>/dev/null || true
	@rm -rf dist/ build/ .coverage htmlcov/ .tox/ .ruff_cache/
	@echo "âœ… Cleanup completed!"

clean-logs: ## Clean log files
	@echo "ðŸ§¹ Cleaning log files..."
	@rm -f logs.log *.log
	@echo "âœ… Log files cleaned!"

clean-venv: ## Remove virtual environment
	@echo "ðŸ—‘ï¸  Removing virtual environment..."
	$(POETRY) env remove --all
	@echo "âœ… Virtual environment removed!"

# Docker operations
docker-build: ## Build Docker image
	@echo "ðŸ³ Building Docker image..."
	docker build -t tai-backend .

docker-run: ## Run Docker container
	@echo "ðŸ³ Running Docker container..."
	docker run -p 8000:8000 --env-file .env tai-backend

# Virtual environment management
venv-info: ## Show virtual environment information
	@echo "ðŸ Virtual Environment Information"
	@echo "================================="
	$(POETRY) env info

venv-activate: ## Show command to activate virtual environment manually
	@echo "ðŸ To manually activate the virtual environment, run:"
	@echo "$(POETRY) shell"

venv-path: ## Show virtual environment path
	@echo "ðŸ“ Virtual environment path:"
	@$(POETRY) env info --path

venv-recreate: ## Recreate virtual environment
	@echo "ðŸ”„ Recreating virtual environment..."
	$(POETRY) env remove --all || true
	$(POETRY) config virtualenvs.in-project true
	$(POETRY) install
	@echo "âœ… Virtual environment recreated!"

# Health checks and info
health: ## Check service health
	@echo "ðŸ¥ Checking service health..."
	@curl -s http://localhost:8000/health 2>/dev/null || echo "âŒ Service not running. Start with 'make dev'"

info: ## Show environment information
	@echo "â„¹ï¸  Environment Information"
	@echo "=========================="
	@echo "Python: $(shell python --version 2>/dev/null || echo 'Not found')"
	@echo "Poetry: $(shell $(POETRY) --version 2>/dev/null || echo 'Not found')"
	@echo "FastAPI: $(shell $(PYTHON) -c 'import fastapi; print(fastapi.__version__)' 2>/dev/null || echo 'Not installed')"
	@echo "Working Directory: $(shell pwd)"
	@echo ""
	@echo "ðŸ”§ Virtual Environment:"
	@$(POETRY) env info --path 2>/dev/null || echo "âŒ No virtual environment found"
	@echo ""
	@echo "ðŸ”§ Configuration:"
	@echo "Host: $(shell grep -E '^HOST=' .env 2>/dev/null | cut -d= -f2 || echo 'localhost')"
	@echo "Port: $(shell grep -E '^PORT=' .env 2>/dev/null | cut -d= -f2 || echo '8000')"
	@echo "Environment: $(shell grep -E '^ENVIRONMENT=' .env 2>/dev/null | cut -d= -f2 || echo 'development')"

# Development workflow shortcuts
setup: install db-init ## Complete setup for new developers
	@echo ""
	@echo "ðŸŽ‰ TAI Backend setup complete!"
	@echo ""
	@echo "ðŸš€ Next steps:"
	@echo "  make dev         # Start the development server"
	@echo "  make test        # Run the test suite"
	@echo "  make admin       # Open admin interface"

check: lint test ## Run all quality checks
	@echo "âœ… All quality checks passed!"

ci: install lint test ## Run CI pipeline locally
	@echo "âœ… CI pipeline completed successfully!"
