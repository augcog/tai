# "Functions Referencing Their Own Names"

##  An interesting consequence of the way environments work is that a function can refer to its own name within its body. Let's look at a couple of examples.

# "A Function That Prints Itself"

##  If I write a function print all that takes some argument and prints it, I can have it return print all. This isn't surprising actually. When you define this function, all that happens is that the body is squirreled away waiting for a call. By the time it's called, the name print all already exists and is already bound to a function. So if I print all one, it will print one and then this expression will evaluate to the print all function, which I could call again. And that expression will evaluate to the print all function, so I could call it again. Let's see what happens. Print all is defined.

# "Understanding Self-Referential Functions in Python"

##  By the time I call print all, notice the print all is already bound in the global frame. I call print all in the first argument one. One gets printed out. In this environment diagram, we also show the print output. And then the function print all is returned. Same function, we looked it up by name, and we returned it. Returning it means that it's the value of print all one. So that's exactly the function that gets called on the argument three. When I call print all on three, three gets printed. Print all is returned. Now I'm going to call that on five. Five gets printed. Print all gets returned. And execution is finished. So even though this refers to itself, since it doesn't call itself, it's not going to run forever. It's up to this call expression to figure out exactly how many times print all gets called. And we see the output are the arguments of the separate calls. Here's a slightly more involved example.

# "A Function to Sum All Arguments"

##  Okay, I'm going to write a function that sums all of the arguments so far. So we'll call it print sums instead. And it's not going to return print all because print all doesn't exist anymore. It will return a function. It's going to return a function that I define within the body of print sums. Called next sum, which takes an argument why and immediately calls print sums on x plus y. That's exactly where the summing is happening. So x is the sum so far. y is the next number. And print sums just returns next sum. Let's see how it works.

# "A Recursive Function: Print Sums"

##  First print sums is defined and then called on the number one. The sum so far is one. And so that's exactly what gets printed out. Next we define a new function and return it. We return it as the value of this call expression. So we'll call it on the number three. So next sum has just been called on the number three. Three is not a sum. It's just the argument here. Where we get a sum is that we're going to add x, which is here in the current environment, in the parent frame of f2, to y and get four. Now what happens to that four is it gets passed into another call to print sums. So there's another call to print sums. Here the argument is four, which is the sum of one and three. And what does print sums do? Well, it just prints out the sum that it receives. And then defines a new function. That new function gets returned. And where does it get returned to? Oh, it's the value of print sums one, three. Notice that the function we're returning, which has parent f3, is the sum so far of four. And so if it wants to compute the sum of the whole thing, one plus three plus five, it needs that four, along with the five that I'm about to pass in. So I've just called next sum, for the second time. Notice that now I'm passing in five. The parent is f3, which contains four, which means I can compute the total sum nine. And what do I do with it? Well, I compute it here, four plus five. I pass it into a third call to print sums, and print sums, print out nine, which is the sum of one and three and five. So by having print sums defined in interfunction, and this interfunction returning a call to print sums, I'm able to use the arguments here to memorize values that get computed along the way. Those values are passed in as arguments. They appear inside the frame, which is the parent frame of the local frame for next sum. Next sum does the summing in this case, and print sums just print out whatever it gets. So here's the same picture, and it's important to notice what goes where.

# "Understanding the Recursive Calls in the Print Sums Function"

##  When you actually have the call expression, print sums, one, three, five, the first call is to print sums, but the other two are to the function that print sums returns, which is the next sum function. So the next sum function just tells Python what to do next in the next call. The next call first gets three. The call after that gets five. So we see that in the print sum frames, we see sums, one, four, and nine. In the next sum frames, we just see the individual arguments that get passed in directly, which are three and five.

